<html>

<head>
<title>平成21年度 春期　基本情報技術者 午後 解説</title>
<style type="text/css">
body{line-height:150%;}
code{font-size:12pt;}
</style>
</head>

<body>

<blockquote>
	<hr>
	<h3 align="center">平成21年度春期試験　正解例と解説(問6～問9)</h3>
	<hr>
	<p><a name="60"><strong>問6</strong></a></p>
	<hr>
	<p><strong><a name="61">設問1</a></strong></p>
	<p>〈解答〉　a：ウ，b：イ</p>
	<p>〈解説〉</p>
	<p>●空欄aについて<br>
	“B社は，A社からシステムの概略機能について説明を受けた後に概算見積を行い，開発期間を3か月として請負契約を結んだ”という記述がある。つまりシステムの概略機能から概算見積りをもとに開発期間を3か月として，A社から要件定義書を受け取った時点で，概算見積りを見直すことなく開発を進めたため，開発期間が当初見積りを超えてしまったと考えられる。したがって原因としてウが適切。</p>
	<p>●空欄bについて<br>
	“M2の操作性を自社判断で一層高めたことによって，開発規模が当初見積りの1.5倍になってしまった”という記述がある。つまりA社との調整なくB社の勝手な判断で機能を拡張してしまったことにより開発規模が当初見積りを超えてしまったと考えられる。したがって原因としてイが適切。</p>
	<hr>
	<p><a href="21S_P_E3.HTM#61">問題へ</a></p>
	<hr>
	<p><strong><a name="62">設問2</a></strong></p>
	<p>〈解答〉　c：エ，d：ウ</p>
	<p>〈解説〉</p>
	<p>●空欄cについて<br>
	空欄cは，生産データ（プログラムの規模など），品質データ（レビュー結果，テスト結果）や進捗データ（プログラムの完成度，プロジェクトの進捗度，計画と実績の差異分析）を分析することにより回避できることである。納期を2週間延ばした後のスケジュールの更なる遅れについては，進捗データの分析によりチェックでき回避できる可能性がある。概算見積りを行った時点よりも要求機能が複雑であったM1の納期遅延については，要求定義を受け取った時点で早期に開発規模の見積りを正確に見直すことが必要であり，こういった分析では回避できない。したがってエが適切。</p>
	<p>●空欄dについて<br>
	空欄dは，開発途中での仕様，開発体制に関する変更管理（変更提案，変更に関する審議・承認など）を進捗会議の場で行うことにより回避できることである。したがって仕様の変更が必要になった場合，変更管理を進捗会議で行うことにより，M2の操作性をB社の自社判断で勝手に高めるといったことによる納期遅延を回避できる可能性がある。したがってウが適切。</p>
	<hr>
	<p><a href="21S_P_E3.HTM#62">問題へ</a></p>
	<hr>
	<p><strong><a name="63">設問3</a></strong></p>
	<p>〈解答〉　e：イ，f：エ</p>
	<p>〈解説〉</p>
	<p>●空欄eについて<br>
	プロジェクトの作業日数の確率分布は，正規分布に近似できると仮定している。<br>
	①M3の作業日数の確率分布は，平均作業日数12.7日，分散4日の正規分布に近似できる。<br>
	②M2の作業日数の確率分布は，平均作業日数12.3日，分散1日の正規分布に近似できる。<br>
	これよりM2及びM3の開発作業全体の作業日数の確率分布は，平均作業日数を12.7＋12.3＝25日（①と②の平均作業日数の和），表2より分散を5日とする正規分布に近似できる。<br>
	したがって空欄eの開発作業全体の平均作業日数は25日になり，イが適切。</p>
	<p>●空欄fについて<br>
	この開発作業全体の作業日数の確率分布では，作業日数が25日±2×2.2日の範囲に収まる確率が0.95である。したがって確率0.95で作業が完了する日数を見積もると，その最長作業日数は平均作業日数25日に2σ＝2×2.2＝4.4日を加えた値になり，空欄fはエが適切。</p>
	<hr>
	<p><a href="21S_P_E3.HTM#63">問題へ</a></p>
	<hr>
	<p><a href="INDEX.HTM">■メニューへ戻る</a> </p>
	<hr>
	<p><a name="70"><strong>問7</strong></a></p>
	<hr>
	<p><a name="71"><strong>設問1</strong></a></p>
	<p>〈解答〉　a：オ，b：ア，c：ア</p>
	<p>●空欄aについて<br>
	空欄aは，需要の傾向変動を把握して需要予測が可能な，需要実績データに含まれる傾向変動である。ヒアリングの結果（3）によると，需要が徐々に増えていく製品と，徐々に減っていく製品とがある。したがって空欄aは，長期的な増加又は減少が継続する傾向変動に該当し，オが適切。</p>
	<p>●空欄bについて<br>
	空欄bは需要の季節変動を把握して需要予測が可能な，需要実績データに含まれる季節変動である。ヒアリングの結果（2）によると，需要の増減パターンが，毎年繰り返される製品がある。したがって空欄bは，増加と減少のパターンが1年ごとに繰り返される季節変動に該当し，アが適切。</p>
	<p>●空欄cについて<br>
	空欄cは不規則変動を除去し平準化することで需要予測が可能な，需要実績データに含まれる不規則変動である。ヒアリングの結果（4）によると，（2），（3）以外の製品は，小幅な需要の増減が不規則に発生している。したがって空欄cは，（2），（3）以外の製品の不規則変動，つまり季節変動や傾向変動では説明できない部分であり，アが適切。</p>
	<hr>
	<p><a href="21S_P_E3.HTM#71">問題へ</a></p>
	<hr>
	<p><a name="72"><strong>設問2</strong></a></p>
	<p>〈解答〉　ウ</p>
	<p>〈解説〉</p>
	<p>製品Xは，需要実績が不規則に変動しながら，徐々に増えていく製品であり，不規則変動を除去し，傾向変動を把握する予測手法が適切。<br>
	製品Yは，需要実績が不規則に変動しながら，需要の増減パターンが毎年繰り返される製品であり，不規則変動を除去し，季節変動を把握する予測手法が適切。<br>
	製品Zは，需要実績が不規則に変動する製品であり，不規則変動の影響を除去し平準化する予測手法が適切。<br>
	したがってウが適切である。</p>
	<hr>
	<p><a href="21S_P_E3.HTM#72">問題へ</a></p>
	<hr>
	<p><strong><a name="73">設問3</a></strong></p>
	<p>〈解答〉　d：ウ，e：オ</p>
	<p>〈解説〉</p>
	<p>●空欄dについて<br>
	　2008年12月の予測値（移動平均法）<br>
	＝（92＋105＋115）÷3<br>
	＝104</p>
	<p>●空欄eについて<br>
	　2008年12月の予測値（指数平滑法）<br>
	＝0.6×115＋（1－0.6）×100<br>
	＝109</p>
	<hr>
	<p><a href="21S_P_E3.HTM#73">問題へ</a></p>
	<hr>
	<p><a href="INDEX.HTM">■メニューへ戻る</a> </p>
	<hr>
	<p><a name="80"><strong>問8</strong></a></p>
	<hr>
	<p><a name="81"><strong>設問</strong></a></p>
	<p>〈解答〉　a：イ，b：ウ，c：イ，d：イ，e：ア，f：オ</p>
	<p>〈解説〉</p>
	<p>●空欄aについて<br>
	副プログラム<code>CheckAndStack(Vt, Ht)</code>の処理では，行38の条件判定で配列<code>Image[Vt, Ht]</code>の画素の色が同じ色<code>CC</code>であれば，画素の色を<code>NC</code>で塗替えた後，変数<code>More</code>をインクリメントし配列<code>VPos[More]</code>，<code>HPos[More]</code>にそれぞれ要素番号<code>Vt</code>，<code>Ht</code>を退避して呼出し元に戻る。したがって行25の最初の<code>CheckAndStack</code>の呼出しで，開始点の画素の色を色<code>NC</code>で塗替える。<br>
	図1では<code>VS</code>＝<code>5</code>，<code>HS</code>＝<code>3</code>として，<code>Image[5, 
	3]</code>を開始点に指定しているので，行25の最初の<code>CheckAndStack</code>の呼出しで，先ず開始点の配列<code>Image[5, 
	3]</code>が黒■で塗り替え，変数<code>More</code>を1にインクリメントし<code>VPos[1]</code>，<code>HPos[1]</code>に開始点の添字<code>5</code>，<code>3</code>をそれぞれ退避する。<br>
	変数<code>More</code>は0から1にインクリメントされているので，行26～34の繰返ループに入り，退避していた開始点の添字を変数V，Hにセットし，変数<code>More</code>を0にデクリメントした後，行30～33で副プログラム<code>CheckAndStack(4, 
	3)</code>，<code>CheckAndStack(5, 2)</code>，<code>CheckAndStack(6, 3)</code>，<code>CheckAndStack(5, 
	4)</code>の呼出しを行う。これらの副プログラムの呼び出しで，開始点に隣接する画素について上→左→下→右の順に同じ領域の色があれば，黒■で塗り替えて，1画素塗り替えるごとに<code>More</code>をインクリメントする。つまり上左下右の画素で塗り替えた個数が<code>More</code>にセットされる（例えば隣接する画素のうち3個を塗り替えると<code>More</code>が3にセットされる）。この後，行26のループ先頭に戻り，さらに塗り替えた最後の画素に隣接する画素について，上→左→下→右の順（反時計回り）に繰返す。<br>
	したがって図1の場合，最初の五つの画素について以下の順に塗り替える。</p>
	<p>①開始点<code>Image[5, 3]</code>を塗り替える</p>
	<p><img border="0" src="img/21S_P_3.gif" width="197" height="196"></p>
	<p>②次に開始点の上に隣接する画素が同じ色なので<code>Image[4, 3]</code>を塗り替える</p>
	<p><img border="0" src="img/21S_P_4.gif" width="196" height="195"></p>
	<p>③次に開始点の左に隣接する画素が同じ色なので<code>Image[5, 2]</code>を塗り替える</p>
	<p><img border="0" src="img/21S_P_5.gif" width="197" height="198"></p>
	<p>④開始点の下に隣接する画素は異なる色なので塗り替えない</p>
	<p>⑤開始点の右に隣接する画素は異なる色なので塗り替えない<br>
	（隣接する4画素のうち2個を塗り替えているので，この時点で<code>More</code>＝<code>2</code>にセットされている）<br>
	次に最後に塗り替えた左に隣接する画素<code>Image[5, 2]</code>に隣接する画素について上→左→下→右の順に繰り返す</p>
	<p>⑥<code>Image[5, 2]</code>の上に隣接する画素が同じ色なので<code>Image[4, 2]</code>を塗り替える</p>
	<p><img border="0" src="img/21S_P_6.gif" width="197" height="197"></p>
	<p>⑦<code>Image[5, 2]</code>の左に隣接する画素は異なる色なので塗り替えない</p>
	<p>⑧<code>Image[5, 2]</code>の下に隣接する画素が同じ色なので<code>Image[6, 2]</code>を塗り替える</p>
	<p><img border="0" src="img/21S_P_7.gif" width="196" height="197"></p>
	<p>したがってイが適切。</p>
	<p>●空欄bについて<br>
	表示領域内のみ塗り替えるには，副プログラム<code>CheckAndStack(Vt, Ht)</code>における行39の<code>Image[Vt, 
	Ht]</code>←<code>NC</code>による塗替処理は，添字<code>Vt</code>，<code>Ht</code>が1≦<code>Vt</code>≦8，1≦<code>Ht</code>≦8の範囲にある場合のみ行う必要がある。<br>
	<code>Vt</code>，<code>Ht</code>のいずれかが0または9の場合，<code>Image[Vt, Ht]</code>＝<code>0</code>になるため行38の条件<code>Image[Vt, 
	Ht]</code>＝<code>CC</code>の判定が偽となり，行39～43の処理を実行せず，表示領域外を塗り替えることなく，副プログラムを終了できる。添字<code>Vt</code>，<code>Ht</code>が<code>1</code>≦<code>Vt</code>≦<code>8</code>，<code>1</code>≦<code>Ht</code>≦<code>8</code>の範囲にある表示領域内の画素である場合は，必ず配列<code>Image[Vt, 
	Ht]</code>の値が色に対応した1～3の値をもつので，条件<code>Image[Vt, Ht]</code>＝<code>CC</code>の判定が真である同じ色の画素について，行39の処理によりを色<code>NC</code>によりを塗替処理を行うことができる。したがって配列<code>Image[Vt, 
	Ht]</code>の各添字が表示領域内であるか否かの範囲チェックを省略でき，ウが適切。</p>
	<p>●空欄cについて<br>
	最外周の画素は表示領域の上下左右の画素なので，2m＋2n＝2（m＋n）個になり，イが適切。</p>
	<p>●空欄dについて<br>
	行12の条件判定により<code>CC</code>＝<code>NC</code>の場合，つまり塗り替える色が同じなら<code>Return</code>命令によりプログラムを終了する。<code>CC</code>≠<code>NC</code>の場合，つまり塗り替える色が異なる場合だけ行15以下を実行するので，行15で<code>Wall</code>←<code>NC</code>としておけば，行38の条件判定<code>Image[Vt, 
	Ht]</code>＝<code>CC</code>を必ず偽とすることができる。したがってイが適切。</p>
	<p>●空欄eについて<br>
	1画素の場合，行25の処理で副プログラム<code>CheckAndStack</code>を呼び出して，同じ領域の色で塗り替えた後，行29の処理で変数<code>More</code>が<code>0</code>にデクリメントされる。その後，行30～33の処理で隣接する画素について上→左→下→右の順に副プログラム<code>CheckAndStack</code>を呼び出しても，上下左右の画素が塗り替えた画素の色とは異なるので，行38の<code>Image[Vt, 
	Ht]</code>＝<code>CC</code>の条件判定が偽となるため，そのまま副プログラムを終了する。そのため変数<code>More</code>の値がインクリメントされず<code>0</code>のまま，行26のループ先頭に戻るが，<code>More</code>＞<code>0</code>が偽となりプログラムを終了する。したがって仕様どおりに同じ色で塗り替えて正しく終了するので，アが適切。</p>
	<p>●空欄fについて<br>
	2画素の場合，行25の処理で副プログラム<code>CheckAndStack</code>を呼出して，同じ領域の色で塗り替えた後，行29の処理で変数<code>More</code>が<code>0</code>にデクリメントされる。その後，行30～33の処理で隣接する画素について上→左→下→右の順に副プログラム<code>CheckAndStack</code>を呼び出すが，右の画素が塗り替えた画素の色と同じなので，行38の<code>Image[Vt, 
	Ht]</code>＝<code>CC</code>の条件判定が真となり，右の画素を塗り替える。そのため変数<code>More</code>の値が<code>1</code>にインクリメントされ，右の画素の添字を配列<code>VPos[1]</code>，<code>HPos[1]</code>に退避して，行26のループ先頭に戻る。ループの繰返条件<code>More</code>＞<code>0</code>が真になるので，退避しておいた右の画素について<code>More</code>を<code>0</code>にデクリメントした後，行30～33の処理で隣接する画素について上→左→下→右の順に副プログラム<code>CheckAndStack</code>を呼び出す。今度は隣接する左の画素が塗り替えた画素の色と同じなので，行38の<code>Image[Vt, 
	Ht]</code>＝<code>CC</code>の条件判定が真となり，左の画素を塗り替える。そのため変数<code>More</code>の値が<code>1</code>にインクリメントされ，今度は左の画素の添字を配列<code>VPos[1]</code>，<code>HPos[1]</code>に退避して，行26のループ先頭に戻る。つまり変数<code>More</code>が<code>0</code>，<code>1</code>の値を交互に繰り返し，左と右の画素を交互に同じ色で塗り替える処理が無限にループする。したがってオが適切。</p>
	<hr>
	<p><a href="21S_P_E3.HTM#81">問題へ</a></p>
	<hr>
	<p><a href="INDEX.HTM">■メニューへ戻る</a> </p>
	<hr>
	<p><a name="90"><strong>問9</strong></a></p>
	<hr>
	<p><strong><a name="91">設問1</a></strong></p>
	<p>〈解答〉　a：カ，b：オ，c：ア，d：オ</p>
	<p>〈解説〉</p>
	<p>●空欄aについて<br>
	変換前の<code>path</code>の先頭の1文字<code>*path</code>が<code>'/'</code>である場合，<code>path</code>は絶対パス表記なので，<code>result</code>には<code>path</code>をそのまま格納すればよい。したがって空欄aはカの<code>strcpy(result, 
	path)</code>が適切。</p>
	<p>●空欄bについて<br>
	変換前の<code>path</code>が“<code>.</code>”または“<code>./</code>”である場合，<code>path</code>はカレントディレクトリなので，<code>result</code>には<code>base</code>をそのまま格納すればよい。したがって空欄bはオの<code>strcpy(result, 
	base)</code>が適切。</p>
	<p>●空欄cについて<br>
	空欄bに関する<code>if</code>文の次の処理で，カレントディレクトリ<code>base</code>の絶対パスの文字列のナル文字を除く個数を<code>length</code>にセットしているので，ポインタbp＝base＋lengthは文字列baseの終端をポイントしている。次の<code>if</code>文の処理は，カレントディレクトリ<code>base</code>の表記の最後に“<code>/</code>”がある場合，ポインタ<code>bp</code>を一つ手前に戻している処理である。<br>
	変換前の<code>path</code>と変換後の絶対パス<code>result</code>の共通部分は<code>path</code>の先頭から“<code>../</code>”が繰り返すところを除いた部分である（例えば変換前のパス“<code>../../b/c/</code>”と変換後の絶対パス“<code>/a/b/c/</code>”の共通部分は変換前のパスの網掛け部分“<code>../../＜網掛け＞b/c/＜／網掛け＞</code>”である）。またカレントディレクトリ<code>base</code>と変換後の絶対パス<code>result</code>の共通部分は，それよりも手前の部分である（カレントディレクトリ<code>base</code>の網掛け部分“<code>＜網掛け＞/a＜／網掛け＞/d/e/</code>”である）。したがって変換前の<code>path</code>の先頭から末尾に向けて，“<code>../</code>”の繰返しが出現しなくなるところまで3文字ごとにポインタ<code>pp</code>を進めて検索しながら，カレントディレクトリ<code>base</code>のポインタ<code>bp</code>を，末尾から先頭に向けて次の区切り“<code>/</code>”が出現するところまで逆に遡れば，ポインタ<code>bp</code>より手前の部分が共通する部分であることになる。これを行っているのが次の<code>for</code>ループの処理である。この<code>for</code>ループの終了時点でのポインタの差<code>bp 
	- base</code>が，変換後の絶対パス<code>result</code>と共通する部分の<code>base</code>の先頭からの文字数を表す。空欄cの直後で，<code>base</code>のパス表記と共通な部分を<code>strncpy</code>関数により<code>result</code>に複写している。したがって複写する文字数<code>length</code>には<code>bp 
	- base</code>をセットすればよく，空欄cはアが適切。</p>
	<p>●空欄dについて<br>
	空欄dの直後の処理で，変換後の絶対パス<code>result</code>のポインタ<code>rp</code>の指す位置に，共通部分の後に続く区切り<code>'/'</code>をセットし，ポインタ<code>rp</code>をインクリメントしている。したがってポインタ<code>rp</code>には<code>result 
	+ length</code>をセットすればよく，空欄dはオが適切。</p>
	<hr>
	<p><a href="21S_P_E3.HTM#91">問題へ</a></p>
	<hr>
	<p><strong><a name="92">設問2</a></strong></p>
	<p>〈解答〉　e：オ，f：イ，g：ア</p>
	<p>〈解説〉</p>
	<p>●空欄eについて<br>
	この場合，変換前の<code>path</code>が“../../../../d/”，カレントディレクトリ<code>base</code>が“<code>/a/b/c/</code>”なので，<code>for</code>ループの3回目の繰返し後，<code>path</code>の文字列の“<code>../../../</code>”まで検索したところで，<code>base</code>の先頭のルートディレクトリ/まで遡ることになる。<code>for</code>ループの4回目の繰返しで<code>path</code>の文字列の“<code>../../../../</code>”まで検索し，<code>pp</code>を3だけ進めた後，次の<code>while</code>ループは<code>bp 
	= base</code>となり終了する。この時点でポインタ<code>pp</code>は文字列“<code>../../../../d/</code>”の文字“<code>d</code>”をポイントするので，<code>for</code>ループの繰返し条件<code>*pp 
	== '.'</code>を満たさず<code>for</code>ループを終了する。したがって<code>length = 0</code>，<code>rp 
	= result</code>にセットされるので，<code>result</code>の先頭に<code>'/'</code>が格納された後，文字列“<code>../../../../d/</code>”から“<code>../../../../</code>”を除いた残りの文字列“<code>d/</code>”が<code>result</code>に追加される。したがって空欄eはオの<code>/d/</code>が適切。</p>
	<p>●空欄fについて<br>
	この場合，変換前の<code>path</code>が<code>d/</code>，カレントディレクトリ<code>base</code>が<code>/a/b/c</code>なので，<code>length 
	= 6</code>にセットされる。<code>bp = base + 6</code>にセットされるが<code>base</code>のパスの表記の最後に<code>'/'</code>がないので，<code>bp</code>は文字<code>c</code>の直後のナル文字をポイントしている。<code>path</code>の文字列が<code>d/</code>なので，<code>for</code>ループの繰返条件を満たさず<code>for</code>ループをそのまま終了するため，ポインタ<code>pp</code>は<code>path</code>の文字<code>d/</code>の先頭にある。空欄cの処理で<code>length 
	= 6</code>にセットされた後，次の<code>strcpy</code>関数により<code>base</code>の6文字<code>/a/b/c</code>が<code>result</code>に格納される。次に空欄dの処理でポインタ<code>rp</code>に<code>result 
	+ 6</code>がセットされ，直後の処理で<code>result</code>の文字<code>/a/b/c</code>の後に<code>'/'</code>が追加される。ポインタ<code>pp</code>は<code>path</code>の文字列<code>d/</code>の先頭文字<code>d</code>をポイントしているので，<code>strcpy(rp, 
	pp)</code>関数により，文字列<code>d/</code>が<code>result</code>の文字列<code>/a/b/c/</code>の後に追加される。したがって空欄fはイの<code>/a/b/c/d/</code>が適切。</p>
	<p>●空欄gについて<br>
	この場合，変換前の<code>path</code>が<code>d</code>，カレントディレクトリ<code>base</code>が<code>/a/b/c/</code>なので，<code>lengt 
	= 7</code>にセットされる。<code>bp = base + 7</code>にセットされるが<code>base</code>のパスの表記の最後に<code>'/'</code>があるので，ポインタ<code>bp</code>は一つ手前に戻され<code>bp 
	= base + 6</code>となり，文字<code>/</code>をポイントしている。<code>path</code>の文字列が<code>d</code>なので，<code>for</code>ループの繰返条件を満たさず<code>for</code>ループをそのまま終了するため，ポインタ<code>pp</code>は<code>path</code>の文字<code>d</code>の先頭にある。空欄cの処理で<code>length 
	= 6</code>セットされた後，次の<code>strcpy</code>関数により<code>base</code>の先頭6文字<code>/a/b/c</code>が<code>result</code>に格納される。次に空欄dの処理でポインタ<code>rp</code>に<code>result 
	+ 6</code>がセットされ，直後の処理で<code>result</code>の文字<code>/a/b/c</code>の後に<code>'/'</code>が追加される。ポインタ<code>pp</code>は<code>path</code>の文字列<code>d</code>の先頭文字<code>d</code>をポイントしているので，<code>strcpy(rp, 
	pp)</code>関数により，文字列<code>d</code>が<code>result</code>の文字列<code>/a/b/c/</code>の後に追加される。したがって空欄gはアの<code>/a/b/c/d</code>が適切。</p>
	<hr>
	<p><a href="21S_P_E3.HTM#92">問題へ</a></p>
	<hr>
	<p><a href="INDEX.HTM">■メニューへ戻る</a></p>
	<hr>
</blockquote>

</body>

</html>
