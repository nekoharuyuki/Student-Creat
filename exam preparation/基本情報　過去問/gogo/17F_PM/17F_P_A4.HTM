<html>
<head>
<title>平成17年度秋期試験　正解例と解説(問10～問13)</title>
</head>

<body bgcolor="#FFFFFF" topmargin="0" leftmargin="0">
<blockquote>
<hr>
<h3 align="center">平成17年度秋期試験　正解例と解説(問10～問13)</h3>
<hr>
<p><a name="100"><b>問10</b></a><b>　</b></p>
<hr>
<p><a name="101"><b>設問1</b></a><b>　</b></p>
<p>＜解答＞a　エ　　　b　エ　　　c　キ</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>関数init( )の呼出しにより，科目ファイルcourse.txtの科目名が配列courseName[courseKey]にセットされ，学生ファイルstudent.txtの学生氏名が構造体STUDENT型の配列student[studentKey]のメンバstudentNameにセットされて，一つ目の履修科目の成績情報へのポインタrFirstCourseにNULLがセットされる。</p>
<p>さらに関数regist( )を含むwhileループの繰返し処理によりRECORD型構造体を生成し，図3のリスト構造がメモリ上に構成される。空欄a，bは関数regist( )の中の処理の1つである。</p>
<p>関数regist( )の冒頭で，構造体RECORD型へのポインタpを宣言し，次のif文の処理で構造体RECORDのメモリ領域への割り付けが成功した場合，ポインタpに割り付けられた領域へのポインタがセットされる。このpが一つ目の履修科目の成績情報へのポインタであり，空欄aを含む処理でSTUDENT型の構造体のメンバstudent[studentKey].rFirstCourseに，このpをセットすればよい。</p>
<p><b>空欄bについて</b></p>
<p>空欄bは成績情報を表すRECORD型構造体のメンバcourseNameに科目名をセットする処理に該当し，空欄bでcourseName[courseKey]をセットすればよい。</p>
<p><b>空欄cについて</b></p>
<p>関数writeCourses( )では，全学生分の履修科目成績一覧をファイルに出力する。空欄cを含むwhileループ直前で，一つ目の履修科目の成績情報への先頭ポインタstudent[studentKey].rFirstCourseがpにセットされ，whileループの繰返しループの中でリストのポインタをたどって，各履修科目の成績情報が取り出され出力ファイルoutput.txtに出力されている。したがって空欄cで科目名と得点をセットするため，p->courseName，p->scoreとすればよい。</p>
<hr>
<a href="17F_P_E4.HTM#101">問題へ</a>
<hr>
<p><a name="102"><b>設問2</b></a><b>　</b></p>
<p>＜解答＞　エ</p>
<p>＜解説＞</p>
<p>次の科目を新たに登録するためメモリ上に割り付けられた構造体RECORDのメンバp->NextCourseに，直前に登録された一つ目の履修科目の成績情報へのポインタstudent[studentKey].rFirstCourseをセットした後，次の科目を新たに登録するためメモリ上に割り付けられた構造体RECORDへのポインタpによりstudent[studentKey].rFirstCourseを更新している。したがって一番最後に関数regist( )により登録された履修科目の成績情報へのポインタが，student[studentKey].rFirstCourseに成績情報への先頭ポインタとしてセットされていることになる。つまり最後にregist( )により登録された成績情報からリストのポインタをたどり，output.txtに出力して行くことになる。</p>
<hr>
<a href="17F_P_E4.HTM#102">問題へ</a>
<hr>
<p><a name="103"><b>設問3</b></a><b>　</b></p>
<p>＜解答＞d　ウ　　　e　カ</p>
<p>＜解説＞</p>
<p><b>空欄dについて</b></p>
<p>空欄d直後の処理でp->rNextCourseにqがセットされ，student[studentkey].rFirstCouseにp（空欄a）がセットされると，ポインタp → qの順にリストをたどって出力される。つまり関数regist( )により新たに登録する科目へのポインタがpで得点がｓなので，得点の降順となるためにはq->score＜sまたはq==NULLの場合に，ポインタp → qの順にたどって出力する必要がある。したがって空欄dはq==NULL || q->score＜sが適切。</p>
<p><b>空欄eについて</b></p>
<p>空欄eを繰返し条件とするwhileループ以下の処理は，空欄dの条件「q==NULL || q->score＜s」が成り立たない場合，つまり新たに登録する科目の得点sが一つ目の履修科目の得点q->scoreよりも小さい場合の処理である。この場合q=q->rNextCourseによりリストのポインタをたどって，得点が降順となる位置を検索して挿入する必要がある。つまりq->rNextCourse->score＞sである間はwhileループによりリストのポインタをたどり，q->rNextCourse->score≦sとなったところでwhileループを抜けて挿入位置の検索を終了すればよい。したがって空欄eの繰返し条件はq->rNextCourse !=NULL && q->rNextCourse->score＞sが適切。</p>
<hr>
<a href="17F_P_E4.HTM#103">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
<p><a name="110"><b>問11</b></a><b>　</b></p>
<hr>
<p><a name="111"><b>設問1</b></a><b>　</b></p>
<p>＜解答＞a　エ　　　b　ア　　　c　オ</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>行24のMOVE命令でフラグ1（S-F1）にSPACEがセットされるが，会員ファイルが検索できなかった場合，行27のMOVE命令によりフラグに "1" がセットされる。したがって空欄aの1行目は「フラグ1に空白を転記する」になる。</p>
<p>行37～39のIF文により会員区分が1または2，つまり学生会員でない場合，行38のMOVE命令によりフラグ2（S-F2）に "1" が転送される。したがって空欄aの4行目は「フラグ2に "1" を転記」になる。</p>
<p>空欄aの2行目は会員ファイルが検索できなかった場合に対応し，「フラグ1に "1" を転記」になる。また空欄aの3行目は会員区分が学生会員である場合に対応するので，「フラグ2に空白を転記」になる。したがって以上よりエが適切。</p>
<p><b>空欄bについて</b></p>
<p>会員ファイルのM-DATEには年月日がYYYYMMDDの形式で英数字項目として左詰めで格納されている。行35のMOVE命令によりM-DATEをW-YEAR1に転送し，この左側6けたの年月をW-YEAR1に格納するには，W-YEAR1がX(6)の英数字項目である必要がある。また行36のIF文の条件式でL-YEAR－W-YEAR2による差を計算しているので，W-YEAR2が9(6)の数字項目でなくてはならない。したがって英数字項目のW-YEAR1を，数字項目のW-YEAR2にREDEFINES句で再定義し変換しているアが適切。</p>
<p><b>空欄cについて</b></p>
<p>例えば現在の年月が200511である場合，入会年月が200412以降200511までの会員が新規入会サービスの対象になる。したがって現在の年月－入会年月＜100となるので，行36のIF文の条件はL-YEAR－W-YEAR2＜100となる。これよりオが適切。</p>
<hr>
<a href="17F_P_E4.HTM#111">問題へ</a>
<hr>
<p><a name="112"><b>設問2</b></a><b>　</b></p>
<p>＜解答＞d　エ　　　e　ウ　　　f　ウ</p>
<p>＜解説＞</p>
<p><b>空欄dについて</b></p>
<p>主プログラムから渡された会員IDの最後の1文字だけが異なる会員コードを抽出するために，PERFORM文の繰返し処理でXを0から9まで変えて最後のけたL-NUM(6)と比較している。したがってXに関する終了条件はX＞9になり，エが適切。</p>
<p><b>空欄eについて</b></p>
<p>会員ファイルを読むためにREAD命令直前の空欄eで，索引キーのセットが必要である。主プログラムから渡された会員ID（L-ID）と最後の1文字だけが異なる会員コードを，会員ファイルの索引キーM-IDにセットする処理に該当するので，ウが適切。</p>
<p><b>空欄fについて</b></p>
<p>会員IDの最後の1文字だけが異なるすべての会員の会員IDと氏名をテーブルS-CORRの要素S-ID(Y)とS-NAME(Y)に格納している処理に該当し，ウが適切。</p>
<hr>
<a href="17F_P_E4.HTM#112">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
<p><a name="120"><b>問12</b></a></p>
<hr>
<p><a name="121"><b>設問1</b></a></p>
<p>＜解答＞a　エ　　　b　オ　　　c　ウ</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>メソッドenter( )は自動改札機を通って入場するときの処理を行う。乗車券が適正でない場合はゲートを閉じ，正常な場合は乗車券に乗車駅の情報を記録する。空欄aを含むif文の条件が成り立つ場合，つまり適正な乗車券である場合，空欄aの処理とメソッドopen( )によるゲートを開くメッセージを出力する処理を行っている。したがって空欄aは乗車駅の情報を記録する処理に該当し，エのticket.setOrigin(this)が適切。</p>
<p><b>空欄bについて</b></p>
<p>空欄bはif文の条件に該当する部分で，空欄bの条件が成り立つ場合，<br>
　①メソッドadjustValue( )による精算処理<br>
　②メソッドsetOrigin( null )による乗車駅の記録を消去する処理<br>
　③メソッドopen( )によるゲートを開くメッセージを出力する処理<br>
を行っている。これらの処理は残高が運賃以上あって精算処理できた場合の処理に該当し，空欄bの条件はオのticket.getValue( ) >= fareが適切。</p>
<p><b>空欄cについて</b></p>
<p>クラスOneWayTicket，PrepaidCardはスーパークラスTicketを継承したサブクラスで，空欄cはそのコンストラクタの定義に関する処理である。したがってス－パークラスTicketのコンストラクタを呼び出して，初期値valueを設定すればよく，空欄cはsuper( value )が適切。</p>
<hr>
<a href="17F_P_E4.HTM#121">問題へ</a>
<hr>
<p><a name="122"><b>設問2</b></a></p>
<p>＜解答＞d　エ　　　e　オ　　　f　コ</p>
<p>＜解説＞</p>
<p><b>空欄dについて</b></p>
<p>新しいタイプの乗車券は，発券した時刻から24時間以内は全駅で乗り降り自由な乗車券なので，抽象クラスTicketを継承して定義される新しい乗車券のクラスのコンストラクタの処理で，valueの初期値に路線の最高運賃を設定し，発券時刻を記録する処理が必要になる。</p>
<p><b>空欄eについて</b></p>
<p>抽象クラスTicketを継承して定義するので，メソッドgetValue( )はスーパークラスで定義された通りでよい。</p>
<p><b>空欄fについて</b></p>
<p>発券から24時間経過すると出場はできるが入場できなくするためには，メソッドisValid( )の処理で，呼び出されたときの時刻がインスタンスに格納されている発券時刻から24時間以内か否かによりtrueまたはfalseを返す処理が必要である。</p>
<hr>
<a href="17F_P_E4.HTM#122">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
<hr>
<p><a name="130"><b>問13</b></a></p>
<hr>
<p><a name="131"><b>設問1</b></a></p>
<p>＜解答＞a　イ　　　b　ウ</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>行8のLAD命令によりGR4には－1，つまり1111 1111 1111 1111がセットされる。さらに行12のLD命令によりGR5に検索対象語が格納され，作業用のGR6にこのGR5の検索対象語が格納される。</p>
<p>行14～15によりGR6の検索対象語とGR4との論理積が，GR2のビットパターンに一致するか照合し，一致すれば行22のFINDにジャンプし，一致した位置のビット番号を算出している。つまりGR4は，GR6の上位ｎビットを取り出すマスクパターンであることが分かる。したがってこのマスクパターンを生成するため，GR4に行8でセットされた1111 1111 1111 1111を(16－ｎ)ビット論理左シフトすればよく，空欄でSLL GR4, 0, GR7とするのが適切。</p>
<p><b>空欄bについて</b></p>
<p>GR3は照合位置のポインタで，0を初期値として，行13～21のLOOP処理でビットパターンと照合するごとに＋１だけインクリメントされる。行18のCPA命令による比較でGR3≦GR7の場合は未照合部分がｎビット以上あることになるので，空欄bの処理の後，行13に戻りビットパターンとの照合を繰り返す。したがって空欄bでGR5の検索対象語を1ビット論理左シフトし，次に照合する部分を上位ｎビットの部分にシフトした後，ビットパターンとの照合を繰り返す必要がある。つまり空欄bでSLL GR5, 1とするのが適切。</p>
<hr>
<a href="17F_P_E4.HTM#131">問題へ</a>
<hr>
<p><a name="132"><b>設問2</b></a></p>
<p>＜解答＞　オ</p>
<p>＜解説＞</p>
<p>LOOP以降の繰返し処理でGR5の検索対象語を1ビットずつ左シフトしながら，GR2のビットパターンを左詰めにした1101 0000 0000 0000と照合するので，検索対象語の最初に出現する1101と一致したとき，GR5の上位4ビットにこの1101がシフトされている必要がある。したがって一致してFINDに制御が移ったとき，GR5には1101 0110 1011 0000がセットされていることになる。これを16進表記にすると#D6B0になる。</p>
<hr>
<a href="17F_P_E4.HTM#132">問題へ</a>
<hr>
<p><a name="133"><b>設問3</b></a></p>
<p>＜解答＞c　カ　　　d　ウ</p>
<p>＜解説＞</p>
<p><b>空欄cについて</b></p>
<p>CALL命令によりBP1SRHを呼び出し，空席を検索して見つかれば，ラベルFINDにジャンプし"予約済"の処理をする。</p>
<p>空欄c直前のSRA命令により，連続するｎ個の空席に相当するｎビットの1のビットを，GR7の上位ｎビットにもつマスクパターンを生成している。空欄c直後のXOR命令により，GR7の内容と＃FFFFとの排他的論理和をとり，見つかった連続するｎ個の空席に相当するｎビットを0にする処理を行っているが，これが"予約済"の処理に相当する。したがって見つかった連続するｎ個の空席に相当するｎビットの1を，見つかった位置にシフトするため，空欄cでGR7のマスクパターンをGR3ビットだけ右シフトする必要があり，空欄cはSRL GR7, 0, GR3が適切。</p>
<p><b>空欄dについて</b></p>
<p>空席が見つかると，GR2には見つかった空席を含む語のアドレスがセットされる。空欄d直前のSUBL命令で，GR2からTBLADD(指定席管理表の先頭の語のアドレス)を差引き，先頭の語から空席の見つかった語の直前までの語数をGR2に求めている。1語が16ビットで16席分に相当するので，空席が確保された一番若い番号の座席番号は，GR2の語数×16＋GR3の内容により計算できる。空欄d直後のADDA命令によりGR2にGR3の内容を加算しているので，空欄dにおいてGR2の語数を16倍する処理が必要で，GR2の内容を4ビット左シフトすればよい。したがって空欄dはSLL GR2, 4が適切。</p>
<hr>
<a href="17F_P_E4.HTM#133">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
</blockquote>
</body>
</html>
