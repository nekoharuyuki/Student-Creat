<html>
<head>
<title>平成17年度秋期試験　正解例と解説(問6〜問9)</title>
</head>

<body bgcolor="#FFFFFF" topmargin="0" leftmargin="0">
<blockquote>
<hr>
<h3 align="center">平成17年度秋期試験　正解例と解説(問6〜問9)</h3>
<hr>
<p><a name="60"><b>問6</b></a><b>　</b></p>
<hr>
<p><a name="61"><b>設問</b></a><b>　</b></p>
<p>＜解答＞a　エ　　　b　ア　　　c　カ　　　d　ク</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>空欄aは更新処理を行うwhileループの繰返し条件になっている。旧定期購読者マスタファイルoldmfおよびトランザクションファイルtrfがともにEOFになったとき，空欄aを含むwhileループを抜けて処理を終わればよい。したがってwhileループの繰返し条件は，「m_stsがEOFでないか，またはt_stsがEOFでない」，つまり（m_sts != EOF） || （t_sts != EOF）になる。</p>
<p><b>空欄bについて</b></p>
<p>空欄bを含む処理は，om_usridとt_usridが等しく，om_magid＜t_magidとなった場合の処理である。つまり旧定期購読者マスタファイルのレコードのうち，購読者コードと雑誌コードの組合せがトランザクションファイルに含まれないものが出現した場合である。この場合，購読終了年月が処理年月以降（om_ldate≧b_date）であれば，旧定期購読者マスタファイルのレコードを新定期購読者マスタファイルに出力すればよい。したがって空欄bはom_usrid，om_magid，om_ldateが適切。</p>
<p><b>空欄c，dについて</b></p>
<p>空欄c，dを含む処理は，om_usridとt_usridが等しく，さらにom_magid＝t_magidとなった場合，つまりトランザクションファイルに含まれるレコードが出現した場合の処理である。この場合，購読終了年月が “999999” である購読打ち切りレコードを除いて，新定期購読者マスタファイルnewmfに出力すればよいので，空欄cはt_ldate != 999999，空欄dはt_usrid，t_magid，t_ldateとすればよい。</p>
<hr>
<a href="17F_P_E3.HTM#61">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
<p><a name="70"><b>問7</b></a><b>　</b></p>
<hr>
<p><a name="71"><b>設問1</b></a><b>　</b></p>
<p>＜解答＞a　カ　　　b　エ</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>AT-ENDがTRUEになるまでPERFORM文の繰返し処理を行うので，空欄aを含むREAD文でIN-FILEがAT ENDになったときAT-ENDをTRUEにセットすればよい。したがって空欄aはカが適切。</p>
<p><b>空欄bについて</b></p>
<p>SORT-RECのCLASS-NO，STUDENT-NO，STUDENT-NAMEに，W-IN-RECのCLASS-NO，STUDENT-NO，STUDENT-NAMEを転送する処理がないので，空欄bでこれを行う必要がある。したがってエが適切。</p>
<hr>
<a href="17F_P_E3.HTM#71">問題へ</a>
<hr>
<p><a name="72"><b>設問2</b></a><b>　</b></p>
<p>＜解答＞c　ウ　　　d　ア</p>
<p>＜解説＞</p>
<p><b>空欄cについて</b></p>
<p>各科目の学年平均点を求めるには，各科目の成績の合計点を求める処理が必要で，これを空欄cで行う必要がある。したがってウが適切。</p>
<p><b>空欄dについて</b></p>
<p>生徒数及び各科目の学年平均点を求めるには，生徒数を求める処理が必要になる。これを空欄dで行う必要がある。したがってアが適切。</p>
<hr>
<a href="17F_P_E3.HTM#72">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
<a name="81"></a>
<p><a name="80"><b>問8</b></a></p>
<hr>
<p>＜解答＞a　ア　　　b　エ　　　c　ウ　　　d　オ</p>
<p>＜解説＞</p>
<p><b>空欄a，bについて</b></p>
<p>　プログラム2のインタフェースCounterの宣言で，抽象メソッドput（String str）が宣言されている。メソッドput（String str）の実際の定義は，単語の出現回数を数えるクラスWordCounterの中と，アルファベットの各文字が単語の先頭に現れた回数を数えるクラスFirstLetterCounterの中でオーバーライドされている。したがってクラスWordCounter及びFirstLetterCounterにインタフェースCounterを多重実装する必要がある。したがって空欄bはエのinplements Counterが適切。</p>
<p>　プログラム5のmain（）メソッドの中で，new演算子によりコンストラクタWordTable（new WordCounter（））を呼び出し，インスタンスwordCountTableを生成している。このときインタフェースCounterを実装したクラスWordCounterのコンストラクタを呼び出して生成したインスタンスを引数として，コンストラクタWordTableを呼び出している。したがって空欄aを含むコンストラクタWordTableの定義で，引数counterをインタフェースCounter型の変数として型宣言しておく必要がある。したがって空欄aはCounterが適切。</p>
<p><b>空欄cについて</b></p>
<p>プログラム1のメソッドput( String line )の処理で，文字列lineを引数としてStringTokenizerクラスのインスタンスを生成し，文字列を空白，コンマ，ピリオドで区切り，単語(トークン)に分解している。whileループの繰返し処理でトークンがまだある間は，メソッドnextToken( )により次の単語を読み出して，空欄cを含むメソッドput( String str )を呼び出し，変数countを用いて出現した単語の回数をカウントしている。メソッドput( String str )を呼び出すごとに，空欄cの処理でint型変数countの初期値を設定している。HashMapはキーと値を関連付けて管理するインタフェースを実装したクラスであるが，そのインスタンスfreqをクラスWordCounterの冒頭で生成した後，空欄c直後のifで出現した単語strに関連付けられた値がある場合，その単語に関連付けられている出現回数の値をget(str)メソッドにより取り出して，変数countに加算している。このif文の直後のfreq.put( str, new Integer(count) )の処理により，出現した単語strとその出現回数countを関連付けて更新している。したがって初めて出現した単語について出現回数を1として関連付ける必要があるので，空欄cで変数count空欄cで変数countの初期値を1としておく必要がある。</p>
<p><b>空欄dについて</b></p>
<p>空欄dは，アルファベットの各文字が単語の先頭に現れた回数を数えるクラスFirstLetterCounterの処理の1つである。変数flFreqは要素数を26とするint型の配列で，単語の先頭に現われたa〜ｚまでの各文字について出現回数を，配列要素flFreq[0]〜flFreq[25]を用いてカウントしている。空欄dは，単語の先頭に各文字が出現するごとに配列要素をインクリメントするテーブル集計の処理に該当する。変数strには出現した単語がセットされるので，単語の先頭の1文字はstr.charAt(0)により取り出せる。したがって空欄dの処理で，単語の先頭の1文字str.charAt(0)に対しflFreq[str.charAt(0)−'a']を+1だけインクリメントする処理を行えばよく，オが適切。</p>
<hr>
<a href="17F_P_E3.HTM#81">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
<p><a name="90"><b>問9</b></a><b>　</b></p>
<p><a name="91"><b>設問1</b></a><b>　</b></p>
<p>＜解答＞a　イ　　　b　ア</P
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>GR2≧#0001の間はLOOPに戻り，GR1の対象データと照合して1の個数を数える処理を繰り返すが，GR2=#0000になれば繰返しループを抜けて終了する。したがって空欄aでJNZ LOOPとすればよい。</p>
<p><b>空欄bについて</b></p>
<p>GR3の内容をGR0に加算しているので，最下位ビットに1が出現すれば1を，最下位ビットに0が出現すれば0をGR3にセットしておく必要がある。したがって直前の空欄bでAND命令によりGR3と#0001との論理積を行えばよい。</p>
<hr>
<a href="17F_P_E3.HTM#91">問題へ</a>
<hr>
<p><a name="92"><b>設問2</b></a><b>　</b></p>
<p>＜解答＞c　ウ　　　d　コ　　　e　イ</p>
<p>＜解説＞</p>
<p><b>空欄cについて</b></p>
<p>GR1に#0555を格納した場合，GR1の対象データの上位5ビットが0なので，プログラム2ではSRL命令による右シフトが11回実行されてGR1が#0000になり，βの処理が11回実行される。</p>
<p>それに対してプログラム1では，GR2のマスクが#8000なので，GR2のSRL命令による右シフトが16回実行されてGR2が#0000になり，αの処理が16回実行される。したがってプログラム2のβの実行回数の方が16−11＝5回少なくなる。</p>
<p><b>空欄d，eについて</b></p>
<p>プログラム2では，SRL命令による右シフトによりGR1が#0000にならないとLOOPの処理が終了しない。したがってプログラム1の命令αの実行回数とプログラム2の命令βの実行回数が等しくなるためには，GR1に格納したデータのビット番号15のビットの値が1である必要がある。</p>
<hr>
<a href="17F_P_E3.HTM#92">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
</blockquote>
</body>
</html>
