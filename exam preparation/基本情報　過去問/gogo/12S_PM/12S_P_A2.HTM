<HTML>
<HEAD>
<TITLE>平成12年度春期試験　(午後問3～問6)</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" topmargin="0" leftmargin="0">
<blockquote>
<hr>
<H3 align="center">平成12年度春期試験　正解例と解説(問3～問6)</H3>
<hr>
<P>
<A NAME="30">
<b>
問3</b></a><b>　</b>

<HR>
<A NAME="31">　<BR>
<b>
設問</b></a>
<p>＜解答＞　ａ　エ　　ｂ　カ　　ｃ　カ　　ｄ　ウ</p>
<p>＜解説＞　　多重プログラミングの問題では、下図のようなグリッド（格子）にタイムチャートを書いて考える。基本的には優先順位をつけずラウンドロビン方式によりプロセスの順番にＰ1→Ｐ2→Ｐ3→Ｐ1→…のように実行するが以下の制約がある。</p>
<table border="0" cellpadding="3" cellspacing="0">
  <tr>
    <td valign="top">(1)</td>
    <td>タイムスライスが50ミリ秒でCPUの使用権が時間切れとなり、待ち行列の最後に回され次のプロセスがCPUで実行される。プロセスＰ3に関しては、130ミリ秒のCPU処理があるためタイムスライスによる時間切れが発生する。さらに</td>
  </tr>
  <tr>
    <td valign="top">(2)</td>
    <td>入出力待ちのプロセスに実行順序が回ってきた場合、そのプロセスを飛ばして、次のプロセスを実行する。例えば入出力待ちのプロセスＰ2に実行順序が回ってきた場合、次のＰ3を実行する。</td>
  </tr>
</table>
<P>
これに注意しタイムチャートを書くと以下のようになる。
<p>3つのプロセスがそれぞれ異なる入出力装置を使用する場合である。</p>
<table border="0" cellpadding="3" cellspacing="0">
  <tr>
    <td valign="top">①</td>
    <td>先ずプロセスＰ1→Ｐ2→Ｐ3の順にCPUでの使用権が与えられる。P1、Ｐ2はCPUでの処理後、それぞれα、βの入出力装置に制御が移り、Ｐ3は50ミリ秒でCPU使用権が時間切れとなる。
      <p><img border="0" src="image/A12s03f1.gif" width="565" height="220"></td>
  </tr>
  <tr>
    <td valign="top">②</td>
    <td>Ｐ3がCPUの時間切れにより、待ち行列の最後尾に回され、次にCPUの使用権のあるＰ1がCPUで実行される。Ｐ1はCPUでの10ミリ秒の処理の後、入出力装置αに制御が移る。
      <p><img border="0" src="image/A12s03f2.gif" width="565" height="220"></td>
  </tr>
  <tr>
    <td valign="top">③</td>
    <td>次にCPUの使用権をもつＰ2は、入出力待ちのプロセスであるため、このＰ2を飛ばして次のＰ3にCPUの使用権が移り実行される。Ｐ3は50ミリ秒でCPUの使用権が時間切れとなり、次にCPUの使用権があるＰ1がCPUで10ミリ秒実行された後、Ｐ2にCPUの使用権が移り実行される。<br>
      　CPUでの処理後、それぞれ入出力装置α、βに制御が移る。
      <p><img border="0" src="image/A12s03f3.gif" width="565" height="220"><br>
    </td>
  </tr>
  <tr>
    <td valign="top">④</td>
    <td>Ｐ2がCPUで20ミリ秒実行された後、待ち行列のＰ3にCPUの使用権が移り、CPUで30ミリ秒（130－50×2＝30ミリ秒）実行される。次にCPUの使用権のあるＰ1がCPUで10ミリ秒実行された後、Ｐ2にCPUの使用権が移るが、Ｐ1、Ｐ2、Ｐ3いずれも入出力待ち状態で、先に入出力を完了したＰ2が実行される。
      <p><img border="0" src="image/A12s03f4.gif" width="565" height="220"></td>
  </tr>
  <tr>
    <td valign="top">⑤</td>
    <td>Ｐ2がCPUで30ミリ秒実行された後、入出力処理を終えて次にCPUの使用権をもつＰ3が実行され、最後にＰ1がCPUで実行される。したがってＰ2が最初に終了し全部のプロセスが終了するまで300ミリ秒かかる。
      <p><img border="0" src="image/A12s03f5.gif" width="565" height="220"><br>
      　</td>
  </tr>
</table>
<p>以下の図まではタイムチャートは同じである。</p>
<p><img border="0" src="image/A12s03f6.gif" width="581" height="220"><br>
　プロセスＰ2、Ｐ3が同一の入出力装置βを使用する場合、開始後200ミリ秒の時点でＰ3のCPU処理が終了したとき、Ｐ2の入出力処理のためβが使用中であるため、Ｐ2の入出力処理終了後にＰ3の入出力処理が行われる。したがって下図より、終了時間が延びるのはＰ3で、320－290＝30ミリ秒延びる。</p>
<p><img border="0" src="image/A12s03f7.gif" width="581" height="220"></p>
<HR WIDTH=100%>
<A HREF="12s_p_e2.htm#31">問題へ</A>
<HR WIDTH=100%>
　<BR>
<a href="index.htm">メニューへ戻る</a>　
<HR WIDTH=100%>
<A NAME="40">　<BR>
<b>
問4</b></a>　
<HR WIDTH=100%>
<A NAME="41">
<b>　<BR>
設問1</b></a>
<p>＜解答＞　ア　</p>
<p>＜解説＞このプログラムの処理では，英単語の配列eitanから単語Ｅを2分探索法で検索し，該当単語があれば単語Ｅとともに入力された訳語Ｊで置き換え，なければ配列最後尾から順にずらして該当位置に英単語Ｅと訳語Ｊを挿入する処理を行っています。2分探索法では，探索するデータが昇順または降順に整列されている必要があります。このプログラムでは探索範囲の中央にある英単語eitan[k]より探索すべき英単語Ｅが小さい場合，次の探索範囲の上限Ｈをｋ－1にセットし，探索範囲をeitan[k]よりも小さな側のデータ列を検索している。したがって英単語配列eitanが昇順に整列されている必要があります。<br>
</p>
<HR WIDTH=100%>
<A HREF="12s_p_e2.htm#41">問題へ</A>
<HR WIDTH=100%>
<A NAME="42">
　<BR>
<b>
設問2</b></a><b>&nbsp;</b> 
&nbsp;＜解答＞　空欄ａ　オ　　　空欄ｂ　キ　　　空欄ｃ　ウ
<p>＜解説＞入力データ①の英単語programは英単語配列に存在するので，条件E=eitan[k]が成り立つのでyesの場合の処理αだけが実行されて，訳語が置き換えられます。これに対して入力データ②の英単語computerは英単語配列にはないので，noの場合の処理βとγだけが実行され，単語と訳語が配列に挿入されます。挿入位置は配列の2番目catと3番目headの間になります。<br>
入力データ③の英単語zooは英単語配列にない単語であり，また配列最後尾のeitan[n]=waterよりも後方に挿入される単語です。したがってzoo＞eitan[n]となりL=ｎ+1にセットされてH＜Lで比較ループを抜けます。L=ｎ+1にセットされｉ≧Lが成り立たないので，配列を後方へずらす処理βは実行されず処理γだけが実行されて配列最後尾の直後eitan[n+1]=zooにセットされます。<br>
　<br> 
　</p>
<HR WIDTH=100%> 
<A HREF="12s_p_e2.htm#42">問題へ</A> 
<HR WIDTH=100%> 
　<BR>
<b><a name="50">問5</a>　</b>
<hr>
<p><b><a name="51">設問1</a>　</b>
</p>
<p>＜解答＞　ア　　
</p>
<p>＜解説＞　is-a  
の関係は、オブジェクトの一般化や特殊化を示し、“A is-a  
B”は、“A は B（の一種）である”ことを示す。V　W is-a X”かつ“X　Y  
is-a Z”の関係があるとき、V と W に共通する性質が X  
であり、X と Y に共通する性質が Z である。  
また，このとき“V　W　X　Y is-a Z”の関係も成り立つ。 
</p> 
<p>宿泊者用エレベータ　運搬用エレベータ　is-a　エレベータ
</p>
<p>レストラン　プール　エレベータ　is-a　サービス設備
</p>
<p>の関係があるので、
</p>
<p>宿泊者用エレベータ　運搬用エレベータ　エレベータ
</p>
<p>レストラン　プール　is-a　サービス設備
</p>
<p>の関係も成り立つ。したがって解答群のアが正解。<br>
</p>
<HR WIDTH=100%>
<a HREF="12s_p_e2.htm#51">問題へ</a>
<HR WIDTH=100%>
　<BR>
<b><a name="52">設問2</a></b>
<p>＜解答＞　カ　　</p>
<p>＜解説＞<b>　</b>　<br>
1 号室　2 号室　is-a　一般室<br>
3 号室　is-a　特別室<br>
一般室　特別室　is-a　客室</p>
<p>の関係があるので、</p>
<p>1 号室　2 号室　3 号室　一般室　特別室　is-a　客室</p>
<p>の関係が成り立つ。また</p>
<p>ベッド　浴室　トイレ　part-of　客室<br>
      サウナ　バルコニー　part-of　特別室</p>
<p>の関係がある。part of 関係のため、どの構成要素が欠けてもオブジェクトとして成り立たない。</p>  
<table border="0" cellpadding="3" cellspacing="0"> 
  <tr> 
    <td valign="top">①</td> 
    <td>客室の構成要素であるトイレが故障した場合、客室オブジェクトとしては成り立たない。したがって客室である１号室の構成要素のトイレが故障した場合、１号室は客室として成り立たない。</td> 
  </tr> 
  <tr> 
    <td valign="top">②</td> 
    <td>特別室の構成要素であるサウナが故障した場合、特別室オブジェクトとしては成り立たない。したがって特別室である３号室の構成要素のサウナが故障した場合、３号室は特別室として成り立たないが、<br> 
      　　　1 号室　2 号室　3 号室　一般室　特別室　is-a　客室<br>
      の関係があるので、客室としての性質は保たれる。</td>
  </tr>
</table>
<p>したがって客室としての性質が保たれるのは、2号室と3号室。</p>
<p>　</p>
<HR WIDTH=100%>
<a HREF="12s_p_e2.htm#52">問題へ</a>
<HR WIDTH=100%>
<p><b><a name="53">設問3</a>　</b></p>
<p>＜解答＞　ウ</p>
<p>＜解説＞　has-a の関係の“A has-a B”は、“A は B を所有している”ことを示す。 B には複数のオブジェクトが指定され、A はそれらを所有するオブジェクトである。 B のオブジェクトが幾つか欠けた場合でも、A はオブジェクトとして成立するものとする。また</p> 
<p>従業員　基本設備　part-of　ホテル<br>
    フロント　客室　ロビー　part-of　基本設備</p>
<p>の関係があるので、</p>
<p>フロント　客室　ロビー　従業員　part-of　ホテル</p>
<p>の関係も成り立ち、ホテルとして成立するために最小限必要なオブジェクトの組合せは</p>
<p>フロント　客室　ロビー　従業員</p>
<p>である。<br>
　</p>
<HR WIDTH=100%>
<a HREF="12s_p_e2.htm#53">問題へ</a>
<hr>
<p>
<A HREF="index.htm">メニューへ戻る</A></p>
<HR WIDTH=100%>
<p><b><a name="60">問6</a>　</b>
</p>
<hr>
<p><b><a name="61">設問1</a>　</b></p>
<p>＜解答＞　　エ　　　　　</p>
<p>＜解説＞　文字の生起確率表の30種類のハフマン符号は次の4つに分類できる。</p>
<table border="0" cellpadding="3" cellspacing="0">
  <tr>
    <td>①</td>
    <td>先頭が0で始まる符号は、3ビット符号である</td>
  </tr>
  <tr>
    <td>②</td>
    <td>先頭が10で始まる符号は、4ビット符号である</td>
  </tr>
  <tr>
    <td>③</td>
    <td>先頭が110か1110か11110で始まる符号は、6ビット符号である</td>
  </tr>
  <tr>
    <td>④</td>
    <td>先頭が11111で始まる符号は8ビット符号である</td>
  </tr>
</table>
<p>　ハフマン符号により符号化されたビット列を、この分類に従い文字に変換すると</p>
<table border="0" cellpadding="3" cellspacing="0">
  <tr>
    <td>アの場合</td>
    <td>イの場合</td>
  </tr>
  <tr>
    <td>　T　　O 　　M 　　　A 　T　　   O&nbsp;</td>
    <td>　A 　P 　　　　P 　　　L 　　　E</td>
  </tr>
  <tr>
    <td>010 1000 110101 011 010 1000</td> 
    <td>  011 110110 110110 110100 001</td> 
  </tr> 
  <tr> 
    <td>ウの場合</td> 
    <td>エの場合</td> 
  </tr> 
  <tr> 
    <td>　P 　　　　O 　T 　A 　　T　　    O</td> 
    <td>　B　　　A　　   N 　　　　　E 　　　L</td>
  </tr>
  <tr>
    <td>    110110 1000 010 011 010 1000&nbsp;</td>
    <td>        111100 011 1010 001 110100 11</td> 
  </tr> 
</table> 
<p>エの場合、末尾の2ビットが変換できず、ハフマン符号のビット列でない。<br> 
<br> 
</p> 
<HR WIDTH=100%> 
<a HREF="12s_p_e2.htm#61">問題へ</a> 
<HR WIDTH=100%> 
　 
<p><b><a name="62">設問2</a>　</b></p>
<p>＜解答＞　a　オ　　　b　ウ</p>
<p>＜解説＞　符号化前の“HOW△ARE△YOU?“は、12文字×8ビット＝96ビットである。<br>
　これをハフマン符号で符号化すると</p>
<table border="0" cellpadding="3" cellspacing="0">
  <tr>
    <td align="center"> H&nbsp;</td>
    <td align="center">    O</td>
    <td align="center">     W</td>
    <td align="center">   △</td>
    <td align="center">  A</td>
    <td align="center">   R</td>
    <td align="center">E</td>
    <td align="center">  △</td>
    <td align="center">    Y</td>
    <td align="center">     O</td>
    <td align="center">     U</td>
    <td align="center">      ?</td>
  </tr>
  <tr>
    <td align="center">    110001</td>
    <td align="center"> 1000</td>
    <td align="center"> 111010</td>
    <td align="center"> 000</td>
    <td align="center"> 011</td>
    <td align="center"> 1011</td>
    <td align="center"> 001</td>
    <td align="center"> 000</td>
    <td align="center"> 111011</td>
    <td align="center"> 1000</td>
    <td align="center"> 110111</td>
    <td align="center"> 11111111</td>
  </tr>
  <tr>
    <td align="center">6</td>
    <td align="center">4</td>
    <td align="center">6</td>
    <td align="center">3</td>
    <td align="center">3</td>
    <td align="center">4</td>
    <td align="center">3</td>
    <td align="center">3</td>
    <td align="center">6</td>
    <td align="center">4</td>
    <td align="center">6</td>
    <td align="center">8</td>
  </tr>
</table>
<p>　に変換され、56ビットとなる。したがって圧縮率は56÷96×100＝58.3…およそ58％になる。</p>
<p>1文字当たりのビット長の期待値</p>
<p>＝Σ（各文字のビット長×各文字の生起確率）</p>
<p>これは以下の①から④の合計になる。</p>
<table border="0" cellpadding="3" cellspacing="0">
  <tr>
    <td valign="top">①</td>
    <td>△からAについては3ビットの符号に変換されるので<br>
      　　　3×（19.0＋9.6＋7.3＋6.5）／100<br>
      　　＝3×（△からAの生起確率の合計）／100<br>
      　　＝3×（△からAの生起確率の累計）／100<br>
      　　＝3×42.4／100<br>
      　　＝1.272</td>
  </tr>
  <tr>
    <td valign="top">②</td>
    <td>OからRについては4ビットの符号に変換されるので<br>
      　　　4×（5.8＋5.6＋5.5＋5.4）／100<br>
      　　＝4×（OからRの生起確率の合計）／100<br>
      　　＝4×（△からRの生起確率の累計－△からAの生起確率の累計）／100<br>
      　　＝4×（64.7－42.4）／100<br>
      　　＝0.892</td>
  </tr>
  <tr>
    <td valign="top">③</td>
    <td>Sから．については6ビットの符号に変換されるので<br>
      　　　6×（5.1＋3.6＋3.1＋ … ＋1.2＋1.0）／100<br> 
      　　＝6×（Sから．の生起確率の合計）／100<br>
      　　＝6×（△から．の生起確率の累計－△からRの生起確率の累計）／100<br>
      　　＝6×（97.3－64.7）／100<br>
      　　＝1.956</td>
  </tr>
  <tr>
    <td valign="top">④</td>
    <td>Vから？については8ビットの符号に変換されるので<br>
      　　　8×（0.9＋0.9＋0.3＋0.2＋0.1＋0.1＋0.1＋0.1）／100<br>
      　　＝8×（Vから？の生起確率の合計）／100<br>
      　　＝8×（△から？の生起確率の累計－△から．の生起確率の累計）／100<br>
      　　＝8×（100.0－97.3）／100<br>
      　　＝0.216</td>
  </tr>
</table>
<p>したがって<br>
　1文字当たりのビット長の期待値＝①＋②＋③＋④<br>
　　　　　　　　　　　　　　　　＝1.272＋0.892＋1.956＋0.216<br>
　　　　　　　　　　　　　　　　＝4.336ビット<br>
　5,000文字のバイト長の期待値＝1文字当たりビット長の期待値×5,000÷8<br>
　　　　　　　　　　　　　　　＝4.336×5,000÷8<br>
　　　　　　　　　　　　　　　＝2,710バイト</p>
<p>　</p>
<HR WIDTH=100%>
<a HREF="12s_p_e2.htm#62">問題へ</a>
<HR WIDTH=100%>
<A HREF="index.htm">メニューへ戻る
</A>
<HR WIDTH=100%>
<p>　</p>
  </blockquote>
</BODY>
</HTML>
