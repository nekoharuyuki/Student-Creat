<html>
<head>
<title>平成18年度春期試験　正解例と解説(問10〜問13)</title>
</head>

<body bgcolor="#FFFFFF" topmargin="0" leftmargin="0">
<blockquote>
<hr>
<h3 align="center">平成18年度春期試験　正解例と解説(問10〜問13)</h3>
<hr>
<p><a name="100"><b>問10</b></a><b>　</b></p>
<hr>
<p><a name="101"><b>設問1</b></a><b>　</b></p>
<p>＜解答＞　a　ア　　　b　ウ　　　c　イ　　　d　ア</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>　終端または文字のいずれかと一致すれば検索を終わり，空欄aを繰返し条件とするwhileループを抜けるが，終端でなく，かつ文字が一致しない間はwhileループにより検索を続ける。したがってwhileループの繰返し条件は，（p != NULL）&&（p->c != c）になり，空欄aはアのp != NULLが適切。</p>
<p><b>空欄bについて</b></p>
<p>　文字が一致しない間（p->c != c）はこの文字に代わる別の文字へのポインタp->otherをたどって検索を続ける必要がある。したがって空欄bはウのp->otherが適切。</p>
<p><b>空欄cについて</b></p>
<p>　終端（p == NULL）または文字のいずれかと一致（p->c == c）すれば検索を終わり，空欄aを繰返し条件とするwhileループを抜ける。p == NULLでこのwhileループを抜けた場合，p->otherがポイントするこの文字に代わる別の文字へのポインタがなく，入力文字列で始まる英単語がなかったことになる。この場合，“単語が見つかりません”と表示すればよいので，空欄cのif文の条件はイのp == NULLが適切。</p>
<p><b>空欄dについて</b></p>
<p>　p->trans == NULLである場合は，入力文字列の検索途中なので，この入力文字に続く文字へのポインタp->followをたどってさらに検索を続ける必要がある。したがって空欄ではアのp->followが適切。</p>
<hr>
<a href="18S_P_E4.HTM#101">問題へ</a>
<hr>
<p><a name="102"><b>設問2</b></a><b>　</b></p>
<p>＜解答＞　エ</p>
<p>＜解説＞</p>
<p>　追加されたαの処理では，入力文字に一致する文字に続く文字をポインタp->followをたどり表示する処理をwhileループの繰返し処理として行っている。空欄はこのwhileループの繰返し条件の一つになっている。</p>
<div>
<table>
<tr>
<td valign="top">ア</td>
<td valign="top">×</td>
<td>“n”と入力した場合，文字“e”についてp->follow == NULLになりwhileループを抜けるので“am”としか表示されない。</td>
</tr>
<tr>
<td valign="top">イ</td>
<td valign="top">×</td>
<td>“m”，“n”いずれを入力しても，ポインタp->followがNULLではないので，whileループに入らずに抜けるので，続く文字が表示されない。</td>
</tr>
<tr>
<td valign="top">ウ</td>
<td valign="top">×</td>
<td>“m”，“n”いずれを入力しても，ポインタp->follow->otherがNULLなので，whileループに入らずに抜けるので，続く文字が表示されない。</td>
</tr>
<tr>
<td valign="top">エ</td>
<td valign="top">○</td>
<td></td>
</tr>
<tr>
<td valign="top">オ</td>
<td valign="top">×</td>
<td>“m”と入力した場合は，ポインタp->otherがNULLでないのでwhileループの処理を行い，“m”に続く“a”を表示する。“n”と入力した場合は，ポインタp->otherがNULLなのでwhileループに入らずに抜けるので，続く文字が表示されない。</td>
</tr>
<tr>
<td valign="top">カ</td>
<td valign="top">×</td>
<td>“m”と入力した場合は，ポインタp->otherがNULLでないのでwhileループに入らずに抜けるので，続く文字が表示されない。“n”と入力した場合は，ポインタp->otherがNULLなのでwhileループの処理を行い，“n”に続く“ame”を表示する。</td>
</tr>
</table></div>
<hr>
<a href="18S_P_E4.HTM#102">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
<p><a name="110"><b>問11</b></a><b>　</b></p>
<hr>
<p><a name="111"><b>設問1</b></a><b>　</b></p>
<p>＜解答＞　a　イ　　　b　カ　　　c　カ　　　d　ア</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>　空欄aが成り立つ場合，上りの方向フラグUP-WAYをTRUEにセットするので，空欄aは上りである条件になる。したがってイのIN-STATION＜OUT-STATIONが適切。</p>
<p><b>空欄bについて</b></p>
<p>　例えば，入場駅が04，出場駅が02の下りの集計の場合，二つの乗車区間03−04，02−01に対応する集計用テーブルに利用者数を集計する必要がある。この乗車区間に対応する下りの集計用テーブルの添字は，4，3ではなく，3，2とする必要がある。したがって空欄bの下りの集計用テーブルの添字はカのTIME-IDX，SECT-IDX−1が適切。</p>
<p><b>空欄cについて</b></p>
<p>　入場駅から出場駅まで乗車区間ごとに利用者数を集計するとき，各駅間の区間所要時間が10分なので，入場時刻に10分ずつ加算しTIME-CNTが60分以上になるごとに利用時間帯TIME-IDXに1加算して利用時間帯をずらして集計する必要がある。したがって空欄cはこの条件になっており，カのTIME-CNT＞＝60が適切。</p>
<p><b>空欄dについて</b></p>
<p>　利用者人数の印刷用テーブルPR-PASSENGERは，各利用時間帯ごとに，上りまたは下りの利用者人数を1行分編集するテーブルなので，乗車区間1〜9に対応するSECT-IDXをテーブルの添字とすればよい。したがって空欄dはアのSECT-IDXが適切。</p>
<hr>
<a href="18S_P_E4.HTM#111">問題へ</a>
<hr>
<p><a name="112"><b>設問2</b></a><b>　</b></p>
<p>＜解答＞　e　ウ　　　f　オ</p>
<p>＜解説＞</p>
<p><b>空欄e，fについて</b></p>
<p>　乗車区間に対応する各駅間の所要時間を行61〜73のPERFORMループの処理でTIME-CNTに加算すればよい。空欄eは上りに対する処理であり，上りの場合の乗車区間SECT-IDXの所要時間はSECT-MM（SECT-IDX）なので，空欄eはウのTIME-CNT＋SECT-MM（SECT-IDX）が適切。<br>
　空欄fは下りに対する処理である。下りの場合は空欄bの場合と同様，乗車区間の添字がSECT-IDX−1となり所要時間はSECT-MM（SECT-IDX−1）なので，空欄eはオのTIME-CNT＋SECT-MM（SECT-IDX−1）が適切。</p>
<hr>
<a href="18S_P_E4.HTM#112">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
<p><a name="120"><b>問12</b></a></p>
<hr>
<p><a name="121"><b>設問</b></a></p>
<p>＜解答＞　a　エ　　　b　イ　　　c　イ　　　d　イ　　　e　エ</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>　Card型配列のオブジェクトのインスタンス配列cards[ ]はstatic型のクラス変数なので，空欄aはエのstatic { が適切。</p>
<p><b>空欄bについて</b></p>
<p>　52枚のカードに対応するインスタンス配列cards[ ]の配列要素のインデックスの範囲は0〜51である。forループにおいて，スートに対応する変数ｉの範囲は0〜3，ランクに対応する変数ｊの範囲は1〜13である。したがって以下のようにイの場合はインデックスの範囲が0〜51になるが，それ以外は0〜51の範囲にならないので，イのｉ*13＋ｊ−1が適切。</p>
<div>
<table>
<tr>
<td>ア</td>
<td>×</td>
<td>インデックスの範囲が1〜52になる</td>
</tr>
<tr>
<td>イ</td>
<td>○</td>
<td></td>
</tr>
<tr>
<td>ウ</td>
<td>×</td>
<td>インデックスの範囲が0〜24になる</td>
</tr>
<tr>
<td>エ</td>
<td>×</td>
<td>インデックスの範囲が13〜13*13＋3になる</td>
</tr>
<tr>
<td>オ</td>
<td>×</td>
<td>インデックスの範囲が12〜13*13＋2になる</td>
</tr>
<tr>
<td>カ</td>
<td>×</td>
<td>インデックスの範囲が3〜54になる</td>
</tr>
</table></div>
<p><b>空欄cについて</b></p>
<p>listの最初から隣り合うカードを調べるので，<br>
　隣り合うカードへのインデックス値adjacentIndex<br>
＝現在注目しているカードのインデックス値＋現在注目しているカードからの相対インデックス値<br>
により求まる。現在注目しているカードからの相対インデックス値は配列diffList[i]として定義されている。<br>
したがって空欄cはイのcurrentIndex ＋ diffList[i]が適切。</p>
<p><b>空欄dについて</b></p>
<p>　空欄dを含むif文の条件が成り立つときに，listのインスタンスからremove（）メソッドにより同じランクの隣り合うカードを削除している。<br>
（（Card） list.get（adjacentIndex））.getRank（ ） == currentRankは隣り合うカードのランクが一致している条件になるが，隣り合うカードのインデックス値adjacentIndexがlist.size（ ）よりも小さく，リスト内の配列要素である必要がある。したがって空欄dはイのadjacentIndex＜list.size（ ）が適切。</p>
<p><b>空欄eについて</b></p>
<p>　現在注目しているカードと同じランクの隣り合うカードのペアを取り除くので，空欄eを引数とするremove（）メソッドにより，現在注目しているカードを取り除く処理が必要である。したがって空欄eはエのcurrentIndexが適切。</p>
<hr>
<a href="18S_P_E4.HTM#121">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
<hr>
<p><a name="130"><b>問13</b></a></p>
<hr>
<p><a name="131"><b>設問1</b></a></p>

<p>＜解答＞a　カ　　　b　イ</p>
<p>＜解説＞</p>
<p><b>空欄aについて</b></p>
<p>　32ビットの被乗数は，上位16ビットが上位語としてGR1に，下位16ビットが下位語としてGR0に16ビットずつに分けて格納されている。GR1，GR0をSLL命令によりGR3ビット論理左シフトすると，上位GR3ビットが左端からはみ出し無視され，シフト前の下位（16−GR3）ビットがシフト後の上位（16−GR3）ビットとして残る。したがって下位語の上位GR3ビットを（16−GR3）ビット，つまりGR4ビット論理右シフトして，上位語の下位GR3ビットに転送する必要がある。メモリアドレスLに退避されている下位語が行19のLD命令によりGR0にロードされ，行20のLD命令によりGR0の下位語がGR5に転送される。空欄aの処理後，行22，23のSLL命令によりGR1，GR0をGR3ビット左論理シフトした後，行24でGR1とGR5との論理和をとっている。したがって空欄aでGR5の下位語を（16−GR3）ビット，つまりGR4ビット論理右シフトする必要があり，空欄aはカのSRL  GR5, 0, GR4が適切。</p>
<p align="center"><img border="0" src="IMAGE/06F_pm_ex_3.gif" width="447" height="455"></p>
<p><b>空欄bについて</b></p>
<p>　被加数の下位語と加数の下位語の加算による桁上がりがGR4の最上位ビットにセットされる。空欄bの直前の行41のSRL命令により15ビット論理右シフトして，GR4の最上位ビットの桁上がりを最下位ビットに移動した後，行43のADDL命令でGR1の加数の上位語に被加数の上位語を加算している。したがって空欄bでGR4の下位語の加算による桁上がりを，GR1の加数の上位語に加算しておく必要があるので，空欄bはイのADDL  GR1, GR4が適切。</p>
<hr>
<a href="18S_P_E4.HTM#131">問題へ</a>
<hr>
<p><a name="132"><b>設問2</b></a></p>
<p>＜解答＞　イ</p>
<p>＜解説＞</p>
<p>　変更前のプログラムで，GR1にセットされる乗数が15ビットである場合，左端の最上位の1ビットを符号ビットとして扱えるので，行15のSLL命令による論理左シフトの結果，左端の最上位ビットが0になるか1になるかによって，フラグレジスタFRの符号フラグSFに0または1がセットされるのを見て，JPL命令による分岐判定を行うことができる。<br>
　GR1にセットされる乗数が16ビットである場合，左端の最上位の1ビットを符号ビットとして扱えないので，行15のSLL命令による論理左シフトの結果，左端の最上位ビットが桁あふれし，この桁あふれしたビットが0か1かの判定が必要になる。SLL命令の結果，桁あふれしたビットがフラグレジスタFRのオーバフローフラグOFにセットされるので，これを見てオーバフロー分岐命令JOVにより分岐判定を行えばよい。この場合，桁あふれしたビットが0であれば何もせずにLPに戻って繰り返し，1であれば行18以降の被乗数の加算処理を行えばよい。したがって桁あふれしたビットが1である場合，分岐命令JOVによりONBITのノーオペレーション命令NOPに分岐すれば行18以降の加算処理が行える。<br>
　これによりイかオのいずれかになるが，オの場合はオーバフロー分岐命令JOVの直前に零分岐命令JZEがあり，GR1にセットされる16ビットの乗数の一番右にある1のビットが，行15のSLL命令により桁あふれしたとき，FINに分岐してしまうので，一番右にある1のビットについて行18以降の加算処理が行えなくなる。したがってイの場合のように先にオーバフロー分岐命令JOVによる分岐判定を行い，その直後で零分岐命令JZEによる分岐を行う必要がある。</p>
<hr>
<a href="18S_P_E4.HTM#132">問題へ</a>
<hr>
<p><a name="133"><b>設問3</b></a></p>
<p>＜解答＞c　エ　　　d　ア</p>
<p>＜解説＞</p>
<p><b>空欄cについて</b></p>
<p>　n＝3の場合なので，GR1＝3から開始して−1されるごとにRMAINをCALLし，GR1＝0で最後のRMAINのCALLを行う。したがってRMAINに4回制御が移るので，エが適切。</p>
<p><b>空欄dについて</b></p>
<p>　行6のLD命令の結果，GR1≠0である間はCONTに分岐し，行11のRETは実行されない。GR1＝0になったときに行11が実行された後，行15に戻って行15〜17におけるNの復元とF（N−1）×Nの計算を再帰処理が終了するまで繰り返す。したがって行11のRET命令の実行は1回のみで，アが適切。</p>
<hr>
<a href="18S_P_E4.HTM#133">問題へ</a>
<hr>
<a href="INDEX.HTM">メニューへ戻る</a>
<hr>
</blockquote>
</body>
</html>