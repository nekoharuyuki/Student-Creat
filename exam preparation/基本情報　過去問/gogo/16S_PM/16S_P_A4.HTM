<HTML>
<HEAD>
<TITLE>平成16年度春期試験　</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" topmargin="0" leftmargin="0">
<blockquote>
  <hr>
  <H3 align="center">平成16年度春期試験　正解例と解説(問10～問13)</H3>
<hr>
<BR>
<b><a name="100">問10</a></b>
<hr> 
<p><b><a name="101">設問1</a>　</b></p> 
<br>＜解答＞　ウ<br>
<br>＜解説＞プログラム1では，3つ目のif文により，“/＊”を検出すると，最初に現れる“＊/”までの文字列を読み飛ばすので，ア，イの場合は正常に動作する。2つ目のif文による二重引用符の検出では，二重引用符を検出すると，関数quote( ‘＼” ’ )により対応する二重引用符を検出するまで，文字列を読み込んでそのまま出力するので，エ，オの場合も正常に動作する。1つ目のif文による一重引用符の検出では，一重引用符を検出すると，関数quote( ‘＼’ ’ )により対応する一重引用符を検出するまで，文字列を読み込んでそのまま出力するが，ウの場合は3つ目の一重引用符に対応する一重引用符がないので，正しく動作しない。<br>
<br>
<HR WIDTH=100%>    
  <a HREF="16S_P_E4.HTM#101">問題へ</a>   
<hr> 
<p><b><a name="102">設問2</a>　</b></p> 
<br>＜解答＞　ａ　オ　　　ｂ　ウ　　　ｃ　キ　　　ｄ　エ　　　ｅ　ア<br>
<br>＜解説＞<br>
空欄ａについて<br>
int型変数quote1は文字定数モードのオンとオフを保持する変数，int型変数quote2は文字列リテラルモードのオンとオフを保持する変数であり，1のときがオン，0のときがオフに対応する。空欄ａを条件とするifの処理は，文字定数または文字列リテラルの中で文字＼を検出した場合の処理なので，空欄ａの条件はquate1 || quate2になる。<br>
<br>
空欄ｂについて<br>
空欄ｂは，文字列リテラル以外のところで一重引用符を検出した場合の処理である。[プログラム2の説明](2)によると，文字定数モードでは一重引用符の出現によって，モードのオンとオフが切り替わる。int型変数quote1は文字定数モードのオンとオフを保持する変数なので，空欄ｂはquote1 = !quote1になる。<br>
<br>
空欄ｃについて<br>
空欄ｂは，文字列定数以外のところで二重引用符を検出した場合の処理である。[プログラム2の説明](3)によると，文字列リテラルモードでは二重引用符の出現によって，モードのオンとオフが切り替わる。int型変数quote2は文字列リテラルモードのオンとオフを保持する変数なので，空欄ｃはquote2 = !quote2になる。<br>
<br>
空欄ｄ，ｅについて<br>
空欄ｄを条件とするifの処理は，文字定数及び文字列リテラル以外で / と＊を検出した場合の処理である。[プログラム2の説明](4)によると，注釈モードでは“/＊”及び“＊/”の出現によって，モードのオンとオフが切り替わる。したがって空欄ｄの条件は( !quote1 && !quote2 )になる。int型変数c_modeは注釈モードのオンとオフを保持する変数であり，1のときがオン，0のときがオフに対応する。したがって文字定数及び文字列リテラル以外，つまり注釈モードで/ と＊を検出した場合の処理である空欄ｅはc_mode = !c_modeになる。<br>
<br>
<HR WIDTH=100%>    
  <a HREF="16S_P_E4.HTM#102">問題へ</a>   
<HR WIDTH=100%>   
  　<BR>
<A HREF="INDEX.HTM">メニューへ戻る</A>
<HR WIDTH=100%>
<BR>
<b><a name="110">問11</a></b>
<hr> 
<p><b><a name="111">設問</a>　</b></p> 
＜解答＞ａ　キ　　　ｂ　エ　　　ｃ　ウ　　　ｄ　カ　　　ｅ　イ　　　ｆ　ア<br>
<br>
＜解説＞空欄ａ～ｃは，PERFORM文の終了条件に関する置換である。<br>
空欄ａについて<br>
行77の終了条件がN = GYOMU-SUである場合，GYOMU-CODE(N－1)，SAGYO-JIKAN(N－1)までしか作業時間月計ファイルに出力できない。GYOMU-CODE(N)，SAGYO-JIKAN(N)までを出力するには，行77の終了条件をN ＞ GYOMU-SUとすべきである。<br>
<br>
空欄ｂについて<br>
GYOMU-CODEテーブルにない新たな業務コードが出現した場合，行48の終了条件を満たさず永久ループになる。GYOMU-CODEテーブルにない新たな業務コードが出現し，N＞GYOMU-SUとなった場合は，次の行51～54のIF文の処理で新たに出現したN-GYOMU-CODEをテーブルのGYOMU-CODE(N)に登録する必要がある。したがって行48の終了条件を<br>
　N ＞ GYOMU-SU OR GYOMU-CODE(N) = N-GYOMU-CODE<br>
とすべきである。<br>
<br>
空欄ｃについて<br>
行44～57のPERFORM文による集計ループでは，社員ごとに1日分の作業時間と業務コード別の作業時間を集計するので，作業日が変ったときだけでなく，社員コードが変った場合，作業日報ファイルのレコードがEOFの場合もこの集計ループを抜ける必要がある。したがって行44の終了条件をEOF = “E” OR N-SHAIN-CODE NOT = SHAIN-CODE OR N-SAGYO-BI NOT = SAGYO-BIとすべきである。<br>
<br>
空欄ｄについて<br>
行44～57のPERFORM文の繰返処理では，作業日報ファイルを読んで以下の2つの集計処理を行っている。<br>
①社員ごとに同一作業日について1日分の作業時間の合計を集計する処理<br>
②社員の業務ごとの作業時間をテーブルSAGYO-JIKAN(N)に分類集計する処理<br>
したがってこのPERFORMループの最後の行56と57の間で，作業日報ファイルの次のレコードを読んで，繰返す必要がある。<br>
<br>
空欄ｅについて<br>
行44～57のPERFORM文による社員ごとの1日分の作業時間を合計するための作業領域であるSAGYO-JIKAN-KEIに関する初期値設定がないので，これをPERFORMループ直前の行41と42の間で行う必要がある。<br>
<br>
空欄ｆについて<br>
GYOMU-CODEテーブルにない新たな業務コードが出現し，N＞GYOMU-SUとなった場合は，次の行51～54のIF文の処理で新たに出現したN-GYOMU-CODEをテーブルのGYOMU-CODE(N)に登録した後，Nの値をGYOMU-SUに更新している。したがってGYOMU-SUは，分類集計でテーブルに登録された業務コードの数であり，各社員の集計ごとにその初期値を0にセットしておく必要がある。行40～65のPERFORM文による集計処理の直前の行36と37の間で，この初期値の設定をしておくべきである。<br>
<br>
<HR WIDTH=100%>    
  <a HREF="16S_P_E4.HTM#111">問題へ</a>   
<HR WIDTH=100%>   
  　<BR>
<A HREF="INDEX.HTM">メニューへ戻る</A>
<HR WIDTH=100%>
<BR>
<b><a name="120">問12</a></b>
<hr> 
<p><b><a name="121">設問</a>　</b></p> 
＜解答＞　　ａ　カ　　　ｂ　エ　　　ｃ　ア　　　ｄ　エ　　　ｅ　エ　　　ｆ　カ<br>
<br>＜解説＞<br>
空欄ａ，ｂについて<br>
インタフェースCharIteratorは，そのインスタンスから文字を順番に取出すための操作を定義している。クラスCharIteratorFactoryには以下の2つのメソッドが定義されている。
空欄ａを含むメソッドgetCharIterator(String data)は，String型のデータから文字を順番に返すCharIteratorのインスタンスを生成して返すメソッドで，空欄ａはその戻り値になっている。したがって空欄ａで，インタフェースCharIteratorを実装するクラスStringCharIterarorのコンストラクタを呼出し，そのインスタンスを返せばよく，空欄ａはnew StringCharIterator(data)になる。<br>
もう1つの空欄ｂを含むメソッドgetCharIterator(char[ ][ ] data)は，char[ ][ ]型の2次元の文字配列から文字を順番に返すCharIteratorのインスタンスを生成して返すメソッドで，空欄ｂはその戻り値になっている。したがって空欄ｂでCharIteratorを実装するクラスChar2DarrayCharIteratorのコンストラクタを呼出し，そのインスタンスを返せばよく，空欄ｂは
new Char2DarrayCharIterator(data)になる。<br>
<br>
空欄ｃ，ｄについて<br>
クラスStringCharIteratorは，インタフェースCharIteratorを実装したクラスであるが，その中にある空欄ｃを含むメソッドhasNext( )，空欄ｄを含むメソッドnext( )は，インタフェースCharaIteratorの抽象メソッドを具体的に定義している部分である。boolean型メソッドhasNext( )は，dataに次の文字があればtrueを返し，なければfalseを戻り値として返す。この戻り値が空欄ｃとなっている。したがって空欄ｃは，index ＜ data.length( )になる。<br>
char型のメソッドnext( )は，次の文字があればdataの次の文字を戻り値として返し，インデックス値を更新する。この戻り値が空欄ｄになっている。したがって空欄ｄはdata.charAt(index++)になる。<br>
<br>
空欄ｅ，ｆについて<br>
クラスChar2DArrayCharIteratorは，インタフェースCharIteratorを実装したクラスであるが，その中にある空欄ｃを含むメソッドhasNext( )，空欄ｄを含むメソッドnext( )は，インタフェースCharaIteratorの抽象メソッドを具体的に定義している部分である。<br>
空欄ｅを含むboolean型のメソッドhasNext( )は，2次元配列data[index1][index2]の要素があればtrueを返し，無ければ次の要素を探し，次の要素が無ければfalseを返す。forループ中にある空欄ｅ直前のif文で，配列data[index1][index2]の要素番号index2に関する終了条件がindex2＜data[index1].lengthとなっているので，index1行目の最後の要素になればindex2を0にして次の行の先頭要素に移ればよい。したがってindex2≧data[index1].lengthとなれば，空欄ｅでindex2 = 0として次の行の先頭要素に移ればよい。<br>
空欄ｆを含むchar型のメソッドnext( )は，hasNext( )を呼出して次の要素があるかどうかを調べ，あればその要素を返し，インデックス値を更新する。if文の条件であるhasNext( )がtrueである場合に，空欄ｆを戻り値として返している。したがって空欄ｆで戻り値としてdata[index1][index2++]を返せばよい（data[index1][index2]を戻り値を返した後，インデックス値index2をindex2++により更新し，次の要素に移っている）。
<br>
<HR WIDTH=100%>    
  <a HREF="16S_P_E4.HTM#121">問題へ</a>   
<HR WIDTH=100%>   
  　<BR>
<A HREF="INDEX.HTM">メニューへ戻る</A>
<HR WIDTH=100%>

<a NAME="130">　<BR>  
<b>  
問13</b></a>　　　（解説は省略します。）
<hr> 
<a NAME="131">　<BR> 
<b> 
設問</b></a><b><a NAME="131">1</a>　</b>
  <p>＜解答＞ａ　イ　　　ｂ　ウ　　　ｃ　イ　　　ｄ　オ<br>

<HR WIDTH=100%> 
  <a HREF="16S_P_E4.HTM#131">問題へ</a> 
<HR WIDTH=100%> 
  <b>　</b> 
<a NAME="132"> 
<b> 
<br>
設問</b></a><b>2</b>
  <p>＜解答＞　ｅ　ク　　　ｆ　エ　　　ｇ　イ</p>

<HR WIDTH=100%>
  <a HREF="16S_P_E4.HTM#132">問題へ</a>
<HR WIDTH=100%>
<p><a HREF="INDEX.HTM">メニューへ戻る</a>　</p>
<HR WIDTH=100%>
  　<BR>
<BR>
  <p>　</p>
</blockquote>
</BODY>
</HTML>
