<html>
<head>
<title>平成22年度 春期 基本情報技術者 午後 問題（問1～問2）</title>
<style type="text/css"><!--
body{line-height:150%;}
code{font-size:12pt;}
h3{text-align:center;}
div.caution{border:solid 1px #000000; padding:0.5em;}
--></style>
</head>
<body>
<blockquote>
<hr>
<h3>平成22年度　春期　基本情報技術者<br/>
午後　問題（問1～問2）</h3>
<hr>
<div class="caution">　次の<strong>問1</strong>から<strong>問7</strong>までの7問については，この中から5問を選択し，選択した問題については，答案用紙の選択欄の（<strong>選</strong>）をマークして解答してください。<br>
　なお，6問以上選択した場合には，はじめの5問について採点します。</div>
<hr>
<p><a name="10"><strong>問1</strong>　キャッシュメモリに関する次の記述を読んで，設問1，2に答えよ。</p>
<p>　キャッシュメモリとは，主記憶とCPUの間に置く高速アクセスが可能なメモリである。キャッシュメモリとCPU及び主記憶との関係を図1に示す。データをキャッシュメモリに保持しておくことによって，CPUは速度の遅い主記憶に直接アクセスしなくて済むので，処理の高速化が図れる。</p>

<p><img src="img/pme01.png"><br/>
図1　キャッシュメモリとCPU及び主記憶との関係</p>

<p>　ここでは，ハードウェアのアーキテクチャを次のように仮定する。<br/>
（1）主記憶はブロック（1ブロックは100語から成る）に分割されている。各ブロックには，その先頭番地が小さいものから順に1，2，3，…とブロック番号が振られている。主記憶とキャッシュメモリ間はブロック単位でデータが転送される。<br/>
（2）キャッシュメモリには，命令を保持しておく命令キャッシュと，データを保持しておくデータキャッシュの2種類がある。ここでは，データキャッシュ（以下，キャッシュという）だけを考える。<br/>
（3）キャッシュの構成は，図2のとおりとする。<br/>
　①　キャッシュは，ディレクトリ部とデータ部から成る。<br/>
　②　データ部はバッファ1～3の三つのバッファから成り，各バッファは1ブロック分の主記憶の内容を保持できる。<br/>
　③　ディレクトリ部は，データ部のバッファ1～3に対応したディレクトリ1～3から成る。それぞれのディレクトリは次の内容を保持する三つのフィールドから成る。<br/>
　なお，データ部のバッファが未使用の場合は，対応するディレクトリの三つのフィールドすべてに0が入っている。<br/>
（イ）　ブロック番号：対応するデータ部のバッファが保持する主記憶のブロック番号<br/>
（ロ）　順位　：キャッシュ内に最も古くから存在するブロックから順に1，2，3と番号が振られる。<br/>
（ハ）　フラグ：対応するデータ部のバッファにブロックを読み込んだとき，0に初期化される。対応するデータ部のバッファに保持されている内容がCPUの処理によって変更されると，1に変わる。</p>

<p><img src="img/pme02-1.png"><br/>
図2　キャッシュの構成</p>

<p>　擬似言語で表現された次の繰返し処理を実行する場合について考える。</p>
<p><img src="img/pme02-2.png"></p>

<p>（1）配列A，B，C及びDは100個の要素から成り，1要素は1語である。添字は0から始まるものとする。<br/>
（2）データ領域の主記憶への割付けは，次のとおりとする。<br/>
　①　Aの配列領域：4000～4099番地（ブロック番号41）<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>A[0]</code>は4000番地，<code>A[1]</code>は4001番地という順に割り付けられる。<br/>
　②　Bの配列領域：4100～4199番地（ブロック番号42）<br/>
　③　Cの配列領域：4200～4299番地（ブロック番号43）<br/>
　④　Dの配列領域：4300～4399番地（ブロック番号44）<br/>
　⑤　定数－1と99の格納領域：4400，4401番地（ブロック番号45）<br/>
（3）変数iはレジスタを使用し，主記憶への割付けは行わない。<br/>
（4）プログラム領域の内容は表1のとおりとする。参照ブロックの数値は，その命令を実行するときにCPUが参照するデータのブロック番号を示す。</p>

<p>表1　プログラム領域の内容<br/>
<img src="img/pme03.png"></p>

<p>　命令の形式は次のとおりとする。<br/>
　<code>LOAD / ADD / STORE   Rn,adr[,Rx]</code>：<br/>
　　　定数<code>adr</code>はアドレスを示す。<code>Rx</code>は指標レジスタである（省略可能）。<code>Rx</code>を指定した場合の実効アドレスは，定数<code>adr</code>と<code>Rx</code>の内容を加算した値が示す番地とする。<br/>
　　　<code>LOAD</code>は，実効アドレスが示す番地に格納されている内容を，レジスタ<code>Rn</code>に設定する。<br/>
　　　<code>ADD</code>は，レジスタRnの内容に実効アドレスが示す番地に格納されている内容を加えて，レジスタ<code>Rn</code>に設定する。<br/>
　　　<code>STORE</code>は，レジスタ<code>Rn</code>の内容を実効アドレスが示す番地に格納する。<br/>
　　　<code>ADDR  Rn,Rm</code>　：レジスタ<code>Rn</code>の内容にレジスタ<code>Rm</code>の内容を加えて，レジスタ<code>Rn</code>に設定する。<br/>
　　　<code>JNM   adr</code>　：直前の演算結果が0以上ならば<code>adr</code>番地へジャンプする。</p>

<hr>
<p><strong><a name="11">設問1</a></strong>　次の（1）～（6）に従って，1000番地の<code>LOAD</code>命令を実行した直後，及び1006番地の<code>STORE</code>命令を最初に実行した直後のディレクトリ部の内容を，図3と図4に示す。［　　 　　］に入れる正しい答えを，解答群の中から選べ。</p>

<p>（1）参照ブロックがキャッシュ内にある場合は，キャッシュ内のデータが使用される。<br/>
（2）参照ブロックがキャッシュ内にない場合（以下，ミスという）は，参照ブロックが主記憶からキャッシュに読み込まれ，対応するディレクトリのフラグの内容は0に初期化される。<br/>
（3）CPUが参照ブロックに対して<code>STORE</code>命令を実行した場合は，対応するディレクトリのフラグの内容は1に変わる。<br/>
（4）ミスが起こったときにキャッシュ内に未使用のバッファがある場合は，未使用のバッファの中で最も番号が小さいバッファに参照ブロックを読み込み，順位を更新する。<br/>
（5）ミスが起こったときにキャッシュ内に未使用のバッファがない場合は，次のキャッシュ更新ロジックを用いる。<br/>
　キャッシュ内に最も古くから存在するブロックが格納されているバッファに，参照ブロックを読み込み，順位を更新する。ただし，対応するディレクトリのフラグの内容が1だったときは，そのブロックを主記憶に書き戻してから，参照ブロックを読み込み，順位を更新する。<br/>
（6）プログラム実行開始時は，キャッシュ内にデータが入っていないものとする。</p>

<p><img src="img/pme04-1.png"><br/>
図3　1000番地のLOAD命令を実行した直後のディレクトリ部</p>

<p><img src="img/pme04-2.png"><br/>
図4　1006番地のSTORE命令を最初に実行した直後のディレクトリ部</p>

<p>解答群<br/>
ア　0<br/>
イ　41<br/>
ウ　42<br/>
エ　43<br/>
オ　44<br/>
カ　45</p>
<hr>
<a href="22S_P_A1.HTM#11">設問1の正解例と解説へ</a>
<hr>
<p><a name="12"><strong>設問2</strong></a>　設問1の（5）のキャッシュ更新ロジックを，次に示す新しいキャッシュ更新ロジックに変えた場合の，ディレクトリ部のブロック番号とフラグの内容の変化を，表2に示す。［　　 　　］に入れる正しい答えを，解答群の中から選べ。</p>
<p>〔新しいキャッシュ更新ロジック〕<br/>
　参照されていない時間が最も長いブロックが格納されているバッファに，参照ブロックを読み込む。<br/>
　なお，この更新ロジックでは，順位の付け方も変更されていて，キャッシュ内で参照されていない時間が最も長いブロックから順に1，2，3と番号が振られる。</p>

<p>表2　ディレクトリ部の内容の変化<br/>
<img src="img/pme05-1.png"></p>

<p>解答群<br/>
<img src="img/pme05-2.png"></p>

<hr>
<a href="22S_P_A1.HTM#12">設問2の正解例と解説へ</a>
<hr>
<a href="INDEX.HTM">■メニューへ戻る</a>
<hr>
<p><strong><a name="20">問2</a></strong>　コンパイラの処理内容に関する次の記述を読んで，設問1～4に答えよ。</p>
<p>　コンパイラとは，プログラム言語で記述された原始プログラムを翻訳して目的プログラムを生成するためのソフトウェアである。コンパイラの処理過程において，構文解析は字句解析が出力する字句を読み込みながら構文木を生成し，その字句の列が文法で許されているかどうかを解析する。</p>
<hr>
<p><strong><a name="21">設問1</a></strong>　次の記述中の［　　 　　］に入れる正しい答えを，解答群の中から選べ。</p>
<p>　2項演算子から成る式の構文は，2分木で表現される。2分木から目的プログラムを生成するには，2分木を深さ優先で探索しながら，帰り掛けに節の演算子を評価する。式の構文木と探索順序の例を図に示す。</p>

<p><img src="img/pme06.png"><br/>
図　構文木と探索順序の例</p>

<p>　探索の結果，図の構文木の例は，aとbに対して演算opを施し，その結果とcに対して演算opを施すと解釈される。<br/>
　括弧を含む式では，演算の優先度は，括弧内の優先度が高く，それ以外は左から右に式を評価する。このとき，次の式に対する構文木は［　　 　　］である。</p>
<p>　式：　a op (b op c) op d</p>
<p>解答群<br/>
ア<br/><img src="img/pme07-1.png"><br/><br/>
イ<br/><img src="img/pme07-2.png"><br/><br/>
ウ<br/><img src="img/pme07-3.png"><br/><br/>
エ<br/><img src="img/pme07-4.png"><br/><br/>
オ<br/><img src="img/pme07-5.png"><br/></p>
<hr>
<a href="22S_P_A1.HTM#21">設問1の正解例と解説へ</a>
<hr>
<p><strong><a name="22">設問2</a></strong>　次の記述中の［　　 　　］に入れる正しい答えを，解答群の中から選べ。</p>
<p>　プログラム言語の文法は，構文規則で規定される。式の構文規則では式の構文を規定しているだけでなく，演算子の優先順位や結合規則も規定している。例として，優先順位が異なる演算子op1，op2と括弧を用いた式の構文規則を考える。</p>

<p>〔式の構文規則〕<br/>
（1）　式　→　項｜式 op1 項<br/>
（2）　項　→　因子｜項 op2 因子<br/>
（3）　因子→　名前｜( 式 )<br/>
（4）　名前→　a｜b｜c｜d｜e<br/>
　“→”は，左側の構文要素が右側で定義されることを示す。<br/>
　“｜”は，“又は”を意味する。</p>
<p>　深さ優先で探索すると仮定すれば，与えられた式に含まれる演算子op1とop2の演算順序は，〔式の構文規則〕から生成可能な構文木で表現できる。例えば，次の式に対して〔式の構文規則〕を適用した構文木は［　　 　　］である。</p>
<p>　式：　a op1 b op2 c op2( d op1 e )</p>
<p>解答群<br/>
ア<br/><img src="img/pme08-1.png"><br/><br/>
イ<br/><img src="img/pme08-2.png"><br/><br/>
ウ<br/><img src="img/pme08-3.png"><br/><br/>
エ<br/><img src="img/pme08-4.png"><br/><br/>
オ<br/><img src="img/pme08-5.png"><br/></p>
<hr>
<a href="22S_P_A1.HTM#22">設問2の正解例と解説へ</a>
<hr>
<p><strong><a name="23">設問3</a></strong>　次の記述中の［　　 　　］に入れる正しい答えを，解答群の中から選べ。</p>
<p>　構文解析した結果は，構文木で表現する以外に，2分木と等価な表現の後置表記法（逆ポーランド表記法）で表現できる。後置表記法では，演算で使用する二つのオペランドを演算子の前に記述する。そして，後置表記法は，構文木を探索して得られる演算順序を表現したものであると考えることができる。例えば，設問1の図の例で，演算子opを加算＋とした場合，後置表記法ではab＋c＋となる。これは，aとbを加算し，その結果とcを加算することを表している。<br/>
　後置表記法を用いて式a×b＋c×d＋eを表現すると［　　 　　］になる。ここで，加算＋と乗算×は，それぞれ設問2の演算子op1とop2に対応し，演算の優先順位や結合規則は，〔式の構文規則〕に従うものとする。</p>
<p>解答群<br/>
ア　abcd××＋e＋<br/>
イ　abc×＋d×e＋<br/>
ウ　ab×cd×＋e＋<br/>
エ　ab×c＋d×e＋</p>
<hr>
<a href="22S_P_A1.HTM#23">設問3の正解例と解説へ</a>
<hr>
<p><strong><a name="24">設問4</a></strong>　次の記述中の［　　 　　］に入れる正しい答えを，解答群の中から選べ。</p>
<p>　後置表記法で表現された式は，スタックを使って左から右に評価することができる。式a＋b＋c×dを後置表記法に変換して評価する場合，スタックの操作順序は［　　 　　］である。ここで，スタックを操作する命令として次の種類がある。また，加算＋と乗算×は，それぞれ設問2の演算子op1とop2に対応し，演算の優先順位や結合規則は，〔式の構文規則〕に従うものとする。</p>
<p>　push(x)：スタックにxをプッシュする</p>

<p><img src="img/pme09-1.png"></p>

<p>　add：スタックからオペランドを二つポップして加算し，その結果をスタックにプッシュする。</p>

<p><img src="img/pme09-2.png"></p>

<p>　mul：スタックからオペランドを二つポップして乗算し，その結果をスタックにプッシュする。</p>
<p>解答群<br/>
ア　push(a)→add→push(b)→add→push(c)→mul→push(d)<br/>
イ　push(a)→push(b)→add→push(c)→mul→push(d)→add<br/>
ウ　push(a)→push(b)→add→push(c)→push(d)→mul→add<br/>
エ　push(a)→push(b)→push(c)→push(d)→add→add→mul</p>
<hr>
<a href="22S_P_A1.HTM#24">設問4の正解例と解説へ</a>
<hr>
<a href="INDEX.HTM">■メニューへ戻る</a>
<hr>
<a href="22S_P_E2.HTM#30">■問3へ進む</a>
<hr>
</blockquote>
</body>
</html>